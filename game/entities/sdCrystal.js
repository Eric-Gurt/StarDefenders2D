
import sdWorld from '../sdWorld.js';
import sdSound from '../sdSound.js';
import sdEntity from './sdEntity.js';
import sdGun from './sdGun.js';
import sdStorage from './sdStorage.js';
import sdPlayerDrone from './sdPlayerDrone.js';
import sdMatterAmplifier from './sdMatterAmplifier.js';
import sdCube from './sdCube.js';
import sdCom from './sdCom.js';
import sdWater from './sdWater.js';
import sdEffect from './sdEffect.js';
import sdGrass from './sdGrass.js';
import sdGuanako from './sdGuanako.js';
import sdStatusEffect from './sdStatusEffect.js';
import sdCharacter from './sdCharacter.js';
import sdTimer from './sdTimer.js';
import sdLost from './sdLost.js';
import sdWeather from './sdWeather.js';
import sdAsp from './sdAsp.js';
import sdRift from './sdRift.js';


class sdCrystal extends sdEntity
{
	static init_class()
	{
		sdCrystal.img_crystal = sdWorld.CreateImageFromFile( 'crystal' );
		sdCrystal.img_crystal_empty = sdWorld.CreateImageFromFile( 'crystal_empty' );
		
		sdCrystal.img_crystal_artificial = sdWorld.CreateImageFromFile( 'crystal_artificial' );
		sdCrystal.img_crystal_artificial_empty = sdWorld.CreateImageFromFile( 'crystal_artificial_empty' );

		sdCrystal.img_crystal_cluster = sdWorld.CreateImageFromFile( 'crystal_cluster' ); // Sprite by HastySnow / LazyRain
		sdCrystal.img_crystal_cluster_empty = sdWorld.CreateImageFromFile( 'crystal_cluster_empty' ); // Sprite by HastySnow / LazyRain

		sdCrystal.img_crystal_cluster2 = sdWorld.CreateImageFromFile( 'crystal_cluster2' ); // Sprite by Darkstar1
		sdCrystal.img_crystal_cluster2_empty = sdWorld.CreateImageFromFile( 'crystal_cluster2_empty' ); // Sprite by Darkstar1
		
		sdCrystal.img_crystal_balloon = sdWorld.CreateImageFromFile( 'crystal_balloon' );
		sdCrystal.img_crystal_balloon_empty = sdWorld.CreateImageFromFile( 'crystal_balloon_empty' );
		
		sdCrystal.img_crystal_crab = sdWorld.CreateImageFromFile( 'sdCrystalCrab' );
		
		sdCrystal.img_crystal_corrupted = sdWorld.CreateImageFromFile( 'crystal_corrupted' );
		
		sdCrystal.img_crystal_crab_big = sdWorld.CreateImageFromFile( 'sdCrystalCrabBig' ); // Sprite by Mrnat444
		
		sdCrystal.img_crystal_quartz = sdWorld.CreateImageFromFile( 'crystal_quartz' ); // Excavator quartz
		sdCrystal.img_crystal_quartz_empty = sdWorld.CreateImageFromFile( 'crystal_quartz_empty' );
		
		sdCrystal.anticrystal_value = 5120 * 16; // 10240;
		
		sdCrystal.max_matter_regen = 400; // Use crystal.max_matter_regen instead
		sdCrystal.max_anti_matter_regen = 100;
		
		sdCrystal.TYPE_CRYSTAL = 1;
		sdCrystal.TYPE_CRYSTAL_BIG = 2;
		sdCrystal.TYPE_CRYSTAL_CRAB = 3;
		sdCrystal.TYPE_CRYSTAL_CORRUPTED = 4;
		sdCrystal.TYPE_CRYSTAL_ARTIFICIAL = 5;
		sdCrystal.TYPE_CRYSTAL_CRAB_BIG = 6;
		sdCrystal.TYPE_CRYSTAL_BALLOON = 7; // Fragile, grow on trees?
		sdCrystal.TYPE_EXCAVATOR_QUARTZ = 8; // Quartz crystal generated by SD excavators
		
		sdCrystal.max_seek_range = 500; // For big crystal crabs

		sdCrystal.recharges_until_depleated = 100;
		
		sdCrystal.hitpoints_artificial = 140;
		
		sdCrystal.lowest_matter_regen = 0; // 20;
		
		sdCrystal.ignored_classes_array = [ 'sdLifeBox' ];
		
		sdCrystal.speciality_table = [];
		sdCrystal.speciality_table[ 40 ] = {
			
			AlterTitle: ( e, base_title )=>
			{
				if ( e.speciality === 1 )
				return 'Mitosis ' + base_title.toLowerCase();
			
				return 'Genesis ' + base_title.toLowerCase();
			},
			
			onThink: ( e, GSPEED )=>
			{
				if ( sdWorld.is_server )
				if ( !e.held_by )
				{
					e._private_props.dupe_timer = ( e._private_props.dupe_timer || 0 ) + GSPEED;
					if ( e._private_props.dupe_timer_max === undefined )
					e._private_props.dupe_timer_max = 90 + Math.random() * 10;

					if ( e._private_props.dupe_timer > e._private_props.dupe_timer_max )
					{
						e._private_props.dupe_timer = 0;

						e._last_damage = sdWorld.time; // Mute
						e.DamageWithEffect( ( e.speciality === 2 ) ? 60 : 30 );
						if ( e._is_being_removed )
						//if ( Math.random() < 0.5 )
						{
							let GetNewType = ()=>
							{
								if ( e.speciality === 2 )
								if ( Math.random() < 0.333 )
								{
									if ( e.type === sdCrystal.TYPE_CRYSTAL || 
										 e.type === sdCrystal.TYPE_CRYSTAL_CORRUPTED || 
										 e.type === sdCrystal.TYPE_CRYSTAL_ARTIFICIAL || 
										 e.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
									return sdCrystal.TYPE_CRYSTAL_CRAB;
								
									if ( e.type === sdCrystal.TYPE_CRYSTAL_CRAB )
									return sdCrystal.TYPE_CRYSTAL_CRAB_BIG;
								
									if ( e.type === sdCrystal.TYPE_CRYSTAL_BIG )
									return sdCrystal.TYPE_CRYSTAL_CRAB_BIG;
								}

								return e.type;
							};
							let GetNewSpeciality = ()=>
							{
								if ( e.speciality === 2 )
								return ( Math.random() < 0.45 ) ? 2 : 1;
									
								return ( Math.random() < 0.45 ) ? 1 : 0;
							};
							
							let a = new sdCrystal({ x:e.x, y:e.y, matter_max: e.matter_max, type: GetNewType(), matter_regen: e.matter_regen, speciality: GetNewSpeciality() });
							let b = new sdCrystal({ x:e.x, y:e.y, matter_max: e.matter_max, type: GetNewType(), matter_regen: e.matter_regen, speciality: GetNewSpeciality() });
							
							if ( !e.is_big )
							if ( a.is_big )
							a.matter_max = a.matter = a.matter_max *= 4;
					
							if ( !e.is_big )
							if ( b.is_big )
							b.matter_max = b.matter = b.matter_max *= 4;
							
							a.sx = e.sx;
							a.sy = e.sy;
							b.sx = e.sx;
							b.sy = e.sy;
							sdEntity.entities.push( a );
							sdEntity.entities.push( b );

							let okA = false;
							let okB = false;
							
							for ( let i = 0; i < 16; i++ )
							{
								let an = Math.random() * Math.PI * 2;
								let r = 4 + ( i / 16 ) * 96;
								let xx = Math.sin( an ) * r;
								let yy = Math.cos( an ) * r;

								
								if ( !okA )
								if ( a.CanMoveWithoutOverlap( e.x-xx, e.y-yy, 0 ) )
								{
									sdCrystal.Zap( e, a, '#aaffaa' );
									a.x = e.x-xx;
									a.y = e.y-yy;
									
									sdWorld.UpdateHashPosition( a, false );
									okA = true;
								}
							
								if ( !okB )
								if ( b.CanMoveWithoutOverlap( e.x+xx, e.y+yy, 0 ) )
								{
									sdCrystal.Zap( e, b, '#aaffaa' );
									b.x = e.x+xx;
									b.y = e.y+yy;
									sdWorld.UpdateHashPosition( b, false );
									okB = true;
								}
							
								if ( okA && okB )
								break;
							}
							if ( !okA )
							{
								a.remove();
								a._broken = false;
							}
							if ( !okB )
							{
								b.remove();
								b._broken = false;
							}
						}
					}
				}
			},
			GetFilterAltering: ( e, ctx_filter )=>
			{
				if ( e.speciality === 1 )
				return ctx_filter + 'hue-rotate(-20deg)brightness(1.5)saturate(0.25)';
			
				return ctx_filter + 'hue-rotate(-40deg)brightness(1.5)saturate(0.5)drop-shadow(0px 0px 5px #aaffaa)';
			},
			onDraw: ( e, ctx, attached )=>
			{
				let phase = sdWorld.time + ( e._net_id || 0 ) * 1239;
				let amp = 5;
				let an = Math.sin( phase / 56 );
				let s = Math.sin( phase / 20 ) * amp * Math.pow( Math.sin( phase / 3000 ), 16 );
				let xx = Math.sin( an ) * s;
				let yy = Math.cos( an ) * s;
				
				ctx.globalAlpha = 1 - Math.abs( s / amp ) * 0.8;
				
				ctx.save();
				{
					ctx.translate( -xx, -yy );
					e._DefaultDraw( ctx, attached );
				}
				ctx.restore();
				
				ctx.globalAlpha = ( 1 - Math.abs( s / amp ) * 0.8 ) * Math.abs( s / amp );
				
				ctx.save();
				{
					ctx.translate( xx, yy );
					e._DefaultDraw( ctx, attached );
				}
				ctx.restore();
				ctx.globalAlpha = 1;
			}
		};
		sdCrystal.speciality_table[ 80 ] = {
			
			AlterTitle: ( e, base_title )=>
			{
				if ( e.speciality === 1 )
				return 'Company-powered ' + base_title.toLowerCase();
			
				return 'Resonance ' + base_title.toLowerCase();
			},
			
			//onThink: ( e, GSPEED )=>
			AlterTimeScale: ( e, GSPEED_scaled )=>
			{
				let friends = 0;
				
				if ( e.is_very_depleted )
				e.speciality = 0;
				else
				if ( e._anything_near )
				for ( let i = 0; i < e._anything_near.length; i++ )
				{
					let e2 = e._anything_near[ i ];
					
					if ( e2.is( sdCrystal ) )
					if ( e2.GetTier() * 40 === 80 )
					{
						if ( e.speciality === 2 )
						if ( e.speciality === e2.speciality )
						if ( e.matter_regen + e2.matter_regen <= e.max_matter_regen )
						if ( e._net_id < e2._net_id )
						if ( !e._is_being_removed )
						if ( !e2._is_being_removed )
						{
							e2.remove();
							sdCrystal.Zap( e, e2, '#aaffff' );
							e.matter_regen = e.matter_regen + e2.matter_regen;
							sdSound.PlaySound({ name:'bsu_attack', x:e.x, y:e.y, volume:0.1, pitch:8 });
							break;
						}
						
						if ( e2.speciality < e.speciality )
						if ( !e2.is_very_depleted )
						{
							e2.speciality = Math.min( e2.speciality + 1, e.speciality );
							sdCrystal.Zap( e, e2, '#aaffff' );
						}
					
						friends++;
						
						if ( friends >= 8 )
						break;
					}
				}
				
				if ( e.speciality === 2 )
				{
					e.ApplyStatusEffect({ type: sdStatusEffect.TYPE_TIME_AMPLIFICATION, t: 90 });
					return GSPEED_scaled * 8 * 10;
				}
				
				if ( friends > 0 )
				e.ApplyStatusEffect({ type: sdStatusEffect.TYPE_TIME_AMPLIFICATION, t: 90 });
				
				return GSPEED_scaled * friends * 10;
			},
			GetFilterAltering: ( e, ctx_filter )=>
			{
				if ( e.speciality === 1 )
				return ctx_filter + 'brightness(1.5)saturate(2)';
			
				return ctx_filter + 'brightness(0.85)contrast(1.5)saturate(2)drop-shadow(0px 0px 5px #aaaaff)';
			}
		};
		sdCrystal.speciality_table[ 160 ] = {
			
			AlterTitle: ( e, base_title )=>
			{
				if ( e.speciality === 1 )
				return 'Explosive ' + base_title.toLowerCase();
			
				return 'Rupture ' + base_title.toLowerCase();
			},
			
			GetFilterAltering: ( e, ctx_filter )=>
			{
				if ( e.speciality === 1 )
				return ctx_filter + 'hue-rotate(-32deg)brightness(0.7)contrast(1.9)saturate(1.5)';
			
				return ctx_filter + 'hue-rotate(-22deg)brightness(0.8)contrast(1.6)saturate(1.5)drop-shadow(0px 0px 5px #ffaaff)';
			},
			
			onDamage: ( e, dmg, initiator=null, was_alive=true )=>
			{
				if ( e._hea <= 0 && was_alive )
				{
					sdWorld.SendEffect({ 
						x:e.x, 
						y:e.y, 
						radius: ( e.speciality === 1 ) ? 35 : 70,
						damage_scale: ( e.speciality === 1 ) ? 3 : 6,
						type:sdEffect.TYPE_EXPLOSION, 
						owner:initiator,
						color:'#a352ff' 
					});
					
					if ( e.speciality === 2 )
					{
						// Let explosion happen first?
						setTimeout( ()=>
						{
							for ( let xx = 0; xx < 2; xx++ )
							for ( let yy = 0; yy < 2; yy++ )
							{
								let ent = new sdCrystal({ 
									x: e.x, 
									y: e.y + e.hitbox_y2, 
									sx: e.sx, 
									sy: e.sy, 
									type: e.type,
									matter_max: e.matter_max,
									matter_regen: Math.min( e.matter_regen * 2, e.max_matter_regen ),
									speciality: e.speciality - 1
								});

								ent.sx += ( xx - 1 ) * 2.5;
								ent.sy += ( yy - 1 ) * 2.5;

								ent.y -= ent.hitbox_y2 + 0.1;

								if ( xx === 0 )
								ent.x -= ent.hitbox_x2 + 0.1;
								else
								ent.x -= ent.hitbox_x1 - 0.1;

								if ( yy === 0 )
								ent.y += ent.hitbox_y1 - ent.hitbox_y2 - 0.1;

								sdEntity.entities.push( ent );
								sdWorld.UpdateHashPosition( ent, false ); // Optional, but will make it visible as early as possible

								if ( !ent.CanMoveWithoutOverlap( ent.x, ent.y, 0 ) )
								{
									ent.x = e.x;
									ent.y = e.y;
								}
							}
							
							sdEntity.Create( sdRift, { type:sdRift.TYPE_CRYSTALLIZED_PORTAL, x:e.x, y:e.y } );
							
						}, 64 );
					}
				}
			}
		};
		sdCrystal.speciality_table[ 320 ] = {
			
			AlterTitle: ( e, base_title )=>
			{
				if ( e.speciality === 1 )
				return 'Jello ' + base_title.toLowerCase();
			
				return 'Regellium ' + base_title.toLowerCase();
			},
			
			GetMaxMatterRegen: ( e )=>
			{
				return sdCrystal.max_matter_regen * 256; // Max capacity equal to overcharged anti?
			},
			
			ImpactAltering: ( e, vel )=>
			{
				vel *= 0.075;
				e._bounce_anim = Math.min( 0.5, vel );

				if ( vel > 0.5 )
				sdSound.PlaySound({ name:'slug_jump', x:e.x, y:e.y, volume: 1 / 3 });

				return vel;
			},
			
			BouncinessAltering: ( e )=>
			{
				if ( Math.abs( e.sx ) < 0.9 )
				if ( Math.abs( e.sy ) < 0.9 )
				return 0;
				
				return 0.95;
			},
			
			GetBleedEffect: ( e )=>
			{
				return sdEffect.TYPE_BLOOD_GREEN;
			},
			
			GetFilterAltering: ( e, ctx_filter )=>
			{
				if ( e.speciality === 1 )
				return ctx_filter + 'hue-rotate(10deg)contrast(0.3)brightness(1.2)saturate(0.7)contrast(4)';
			
				if ( e.matter_regen >= 1600 ) // Behaves like 5120 crystal at this regen rate
				return ctx_filter + 'hue-rotate(-90deg)contrast(0.3)brightness(1.2)saturate(0.7)contrast(4)drop-shadow(0px 0px 5px #ffffaa)';
				else
				return ctx_filter + 'hue-rotate(-90deg)contrast(0.3)brightness(1.2)saturate(0.7)contrast(4)';
			
				//return ctx_filter + 'hue-rotate(-50deg)contrast(0.3)brightness(1.2)saturate(0.7)contrast(4)';
			},
			
			onDraw: ( e, ctx, attached )=>
			{
				ctx.scale( 1 + e._bounce_anim / 2, 1 - e._bounce_anim );
				e._DefaultDraw( ctx, attached );
			},
			
			onThink: ( e, GSPEED )=>
			{
				e._bounce_anim = Math.max( 0, e._bounce_anim - GSPEED * 0.15 );
			}
		};
		sdCrystal.speciality_table[ 640 ] = {
			
			AlterTitle: ( e, base_title )=>
			{
				if ( e.speciality === 1 )
				return 'Damage-charged ' + base_title.toLowerCase();
			
				return 'Painite ' + base_title.toLowerCase();
			},
			
			GetFilterAltering: ( e, ctx_filter )=>
			{
				if ( e.speciality === 1 )
				return ctx_filter + 'hue-rotate(-20deg)brightness(0.85)saturate(1.6)contrast(2)drop-shadow(0px 0px 1px #ff0000)';
			
				return ctx_filter + 'hue-rotate(-50deg)brightness(0.55)contrast(1.7)saturate(1.2)drop-shadow(0px 0px 1px #ff0000)drop-shadow(0px 0px 5px #ff666666)';
			},
			
			onThink: ( e, GSPEED )=>
			{
				if ( e.speciality === 1 ) // Tier 2 does not lose regen overtime
				e.matter_regen = Math.max( 0, e.matter_regen - GSPEED * 0.01 );
			},
			
			GetMaxMatterRegen: ( e )=>
			{
				if ( e.speciality === 2 )
				return sdCrystal.max_matter_regen * 2; // Double max matter capacity than usual
			
				return sdCrystal.max_matter_regen;
			},
			
			onDamage: ( e, dmg, initiator=null, was_alive=true )=>
			{
				// Take less damage
				if ( e.speciality === 2 )
				{
					e._hea = Math.min( e._hmax, e._hea + dmg * 0.9 );
					dmg *= 0.1;
				}
				
				if ( e._hea > 0 )
				{
					let damage_to_consume = e.max_matter_regen - e.matter_regen;
					
					e._hea += Math.min( damage_to_consume, dmg );
					
					e.matter_regen = Math.min( e.max_matter_regen, e.matter_regen + dmg );
				}
			}
			
		};
		sdCrystal.speciality_table[ 1280 ] = {
			
			AlterTitle: ( e, base_title )=>
			{
				if ( e.speciality === 1 )
				return 'Zap-charged ' + base_title.toLowerCase();
			
				return 'Drainite ' + base_title.toLowerCase();
			},
			
			GetFilterAltering: ( e, ctx_filter )=>
			{
				if ( e.speciality === 1 )
				return ctx_filter + 'hue-rotate(-95deg)saturate(1)brightness(2)drop-shadow(0px 0px 1px #aaddff)';
				
				return ctx_filter + 'hue-rotate(-80deg)saturate(1)brightness(1.5)drop-shadow(0px 0px 1px #aaaaff)';
			},
			
			onThink: ( e, GSPEED )=>
			{
				if ( sdWorld.is_server )
				if ( !e.held_by || !e.held_by.is( sdMatterAmplifier ) || !e.held_by.shielded )
				{
					e._private_props.zap_timer = ( e._private_props.zap_timer || 0 ) + GSPEED;
					
					if ( e._private_props.zap_timer > 60 )
					{
						e._private_props.zap_timer -= 60 * ( 0.5 + Math.random() * 0.5 );
						
						if ( e._anything_near )
						{
							if ( e.speciality === 1 )
							{
								let matter_demand = Math.min( e.matter_max - e.matter, e.matter_max * 0.1 );

								let play_sound = 0;

								for ( let i = 0; i < e._anything_near.length; i++ )
								{
									let e2 = e._anything_near[ i ];

									if ( e2.IsTargetable( e ) )
									{
										let old_matter = ( e2.matter || e2._matter || 0 );
										if ( old_matter >= matter_demand && old_matter > 20 )
										{
											e2.TransferMatter( e, matter_demand, 1, true );

											let new_matter = ( e2.matter || e2._matter || 0 );

											if ( old_matter !== new_matter )
											{
												sdCrystal.Zap( e, e2, '#aaddff' );
												play_sound = 1;
											}

											matter_demand -= ( old_matter - new_matter );

											if ( matter_demand <= 0 )
											break;
										}
									}
								}

								if ( matter_demand > 0 )
								{
									for ( let i = 0; i < e._anything_near.length; i++ )
									{
										let e2 = e._anything_near[ i ];

										if ( e2.IsTargetable( e ) )
										{
											let old_hp = ( e2.hea || e2._hea || 0 );

											e2.DamageWithEffect( 40, e, false, false );

											let new_hp = ( e2.hea || e2._hea || 0 );

											if ( old_hp !== new_hp )
											{
												sdCrystal.Zap( e, e2, '#ffaa00' );
												play_sound = 2;
											}

											let value = ( old_hp - new_hp );// / 0.15;

											e.matter = Math.min( e.matter_max, e.matter + value );
											matter_demand -= value;

											if ( matter_demand <= 0 )
											break;
										}
									}
								}

								if ( play_sound )
								sdSound.PlaySound({ name:'drone_explosion', x:e.x, y:e.y, volume:1, pitch: ( play_sound === 1 ) ? 0.8 : 0.6 });
							}
							else
							if ( e.speciality === 2 )
							{
								if ( e.is_very_depleted )
								{
									e.speciality = 1;
								}
								else
								if ( e.matter_regen < e.max_matter_regen )
								{
									let demand = e.max_matter_regen - e.matter_regen;
									for ( let i = 0; i < e._anything_near.length; i++ )
									{
										let e2 = e._anything_near[ i ];

										if ( e2.is( sdCrystal ) )
										if ( e2.IsTargetable( e ) )
										if ( e2.matter_regen > 0 )
										{
											let demand_to_e2_regen = demand * e.matter_max / e2.matter_max;
											
											if ( e2.matter_regen > demand_to_e2_regen )
											{
												e2.matter_regen -= demand_to_e2_regen;
												e.matter_regen += demand;
												demand = 0;
												
												sdCrystal.Zap( e, e2, '#ffaa00' );
												sdSound.PlaySound({ name:'drone_explosion', x:e.x, y:e.y, volume:1, pitch: 0.7 });
												
												break;
											}
											else
											{
												demand_to_e2_regen = e2.matter_regen;
												
												e.matter_regen += demand_to_e2_regen * e2.matter_max / e.matter_max;
												
												sdCrystal.Zap( e, e2, '#ffaa00' );
												sdSound.PlaySound({ name:'drone_explosion', x:e.x, y:e.y, volume:demand_to_e2_regen * e2.matter_max / e.matter_max / demand, pitch: 0.7 });
												
												e2.matter_regen = 0;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		};
		sdCrystal.speciality_table[ 2560 ] = {
			
			AlterTitle: ( e, base_title )=>
			{
				if ( e.speciality === 1 )
				return 'Soul taking ' + base_title.toLowerCase();
			
				return 'Symbiotic co-pilot ' + base_title.toLowerCase();
			},
			
			GetFilterAltering: ( e, ctx_filter )=>
			{
				if ( e.speciality === 1 )
				return ctx_filter + 'brightness(0.6)contrast(2)saturate(0.3)drop-shadow(0px 0px 1px #000000)';
			
				return ctx_filter + 'brightness(0.7)contrast(2)saturate(0.1)drop-shadow(0px 0px 1px #000000)';
			},
			
			onThink: ( e, GSPEED )=>
			{
				if ( sdWorld.is_server )
				if ( !e.held_by || !e.held_by.is( sdMatterAmplifier ) || !e.held_by.shielded )
				{
					e._private_props.is_busy = Math.max( 0, ( e._private_props.is_busy || 0 ) - GSPEED );
					
					e._private_props.host_net_id = e._private_props.host_net_id || -1;
					
					const BindTo = ( e2 )=>
					{
						if ( e._private_props.host_net_id === e2._net_id )
						return;
					
						if ( e._private_props.is_busy <= 0 )
						{
							e2.Say( sdWorld.AnyOf([ 
								'I don\'t really like this...',
								'Oh well...',
								'Not this thing again...',
								'It has chosen me'
							]) );

							e._private_props.is_busy = 60;
							sdSound.PlaySound({ name:'alien_energy_power_charge1', x:e.x, y:e.y, volume:1, pitch:2 });
							sdCrystal.Zap( e, e2, '#ffaaaa' );

							e._private_props.host_net_id = e2._net_id;
						}
					};
					
					if ( e.speciality === 2 )
					if ( e.held_by )
					if ( e.held_by.is( sdCharacter ) )
					{
						BindTo( e.held_by );
					}
					
					//if ( e._private_props.host_net_id && e._private_props.host_net_id._is_being_removed )
					//e._private_props.host_net_id = null;
					
					if ( e._private_props.is_busy <= 0 )
					if ( e.speciality === 2 || Math.random() < 0.1 )
					{
						const VisitEntity = ( e2 )=>
						{
							if ( e._private_props.is_busy > 0 )
							return;
						
							let ef = e2.GetBleedEffect();
							
							let is_player = ( 
									e2.is( sdCharacter ) && 
									e2.biometry >= 0 && // Real player, not a fake RTP copy that is made on death
									!e2._ai_enabled );

							let value = Math.max( 3, ( e2._score || 0 ) );

							if ( 
									( 
										is_player && 
										(
											( e2.hea || e2._hea || 0 ) < ( e2.hmax || e2._hmax || 0 ) 
											|| 
											e.speciality === 2 
										)
									) 
									|| 
									( 
										!is_player && 
										(
											ef === sdEffect.TYPE_BLOOD || 
											ef === sdEffect.TYPE_BLOOD_GREEN 
										) 
									)
							)
							{
								if ( e2.IsTargetable( e ) )
								{
									const Check = ()=>
									{
										return ( !e._is_being_removed && !e2._is_being_removed && sdWorld.inDist2D_Boolean( e.x, e.y, e2.x, e2.y, 300 ) && e2.IsTargetable( e ) && sdWorld.CheckLineOfSight2( e.x, e.y, e2.x+(e2.hitbox_x1+e2.hitbox_x2)/2, e2.y+(e2.hitbox_y1+e2.hitbox_y2)/2, e,e2, null, sdCom.com_visibility_unignored_classes ) )
									};

									if ( Check() )
									{
										if ( e.speciality === 2 )
										{
											if ( e._private_props.host_net_id === -1 )
											{
												if ( e2.is( sdCharacter ) )
												{
													BindTo( e2 );
												}
											}
											else
											if ( e2._net_id !== e._private_props.host_net_id )
											if ( e2.is_alive )
											{
												sdCrystal.Zap( e, e2, '#ffaaaa' );
												e._private_props.is_busy = 30 / 1000 * 150;
												
												e._private_props.last_target_net_id = e2._net_id;

												if ( sdWorld.time > e._private_props.last_attack_time + 1000 )
												sdSound.PlaySound({ name:'alien_energy_power_charge1', x:e.x, y:e.y, volume:1, pitch:2 });

												e._private_props.last_attack_time = sdWorld.time;

												e2.DamageWithEffect( 50, e, false, false );
												e._hea = Math.min( e._hmax, e._hea + 25 );

												if ( !e2.is_alive )
												{
													e.matter_regen = Math.min( e.matter_regen + value, e.max_matter_regen );

													sdSound.PlaySound({ name:'gun_anti_rifle_hit', x:e.x, y:e.y, volume:1.5, pitch:0.6 });

													sdWorld.SendEffect({ 
														x:e2.x, 
														y:e2.y, 
														radius:50, // 80 was too much?
														damage_scale: 0, // 5 was too deadly on relatively far range
														type:sdEffect.TYPE_EXPLOSION, 
														//owner:e,
														color:'#ffaaaa' 
													});

													e.ApplyStatusEffect({ type: sdStatusEffect.TYPE_TIME_AMPLIFICATION, t: 30 * 30 });
													
													e._private_props.last_attack_time = 0;
												}
											}
										}
										else
										{
											e._private_props.is_busy = 90;

											sdSound.PlaySound({ name:'alien_energy_power_charge1', x:e.x, y:e.y, volume:1, pitch:2 });

											sdCrystal.Zap( e, e2, '#ffaaaa' );

											let time_scale = 150;


											if ( e2.is( sdCharacter ) )
											{
												e2.Say( sdWorld.AnyOf([ 
													'Oh no!',
													'Run!',
													'Run away!',
													'Hide!',
													'It instakills!'
												]) );
											}

											for ( let i = 1; i < 10; i++ )
											setTimeout(()=>{
												if ( Check() )
												sdCrystal.Zap( e, e2, '#ffaaaa' );
											}, i * time_scale );

											setTimeout(()=>{

												e._private_props.is_busy = 30;

												if ( Check() )
												{
													sdSound.PlaySound({ name:'gun_anti_rifle_hit', x:e.x, y:e.y, volume:1.5, pitch:0.6 });

													if ( e2.is( sdCharacter ) && ( e2._god || e2.AttemptTeleportOut( null, true ) ) )
													{
														// Saved by cloner
													}
													else
													{
														let old_biometry = e2.biometry;

														if ( typeof e2.biometry !== 'undefined' )
														e2.biometry = -3;

														e2.DamageWithEffect( 10000, e, false, false );
														sdCrystal.Zap( e, e2, '#ffaaaa' );

														if ( e2._is_being_removed )
														{
															e.matter_regen = Math.min( e.matter_regen + value, e.max_matter_regen );

															sdWorld.SendEffect({ 
																x:e2.x, 
																y:e2.y, 
																radius:50, // 80 was too much?
																damage_scale: 0, // 5 was too deadly on relatively far range
																type:sdEffect.TYPE_EXPLOSION, 
																//owner:e,
																color:'#ffaaaa' 
															});

															e.ApplyStatusEffect({ type: sdStatusEffect.TYPE_TIME_AMPLIFICATION, t: 30 * 30 });
														}
														else
														{
															if ( typeof e2.biometry !== 'undefined' )
															e2.biometry = old_biometry;
														}
													}
												}

											}, 10 * time_scale );
										}
									}
								}
							}
						};
						
						let e2 = e.GetRandomEntityNearby( 300 );
						if ( e2 )
						VisitEntity( e2 );
					
						if ( e.speciality === 2 )
						if ( e._private_props.last_target_net_id >= 0 )
						{
							let e2 = sdEntity.entities_by_net_id_cache_map.get( e._private_props.last_target_net_id );
							
							if ( !e2 || e2._is_being_removed )
							e._private_props.last_target_net_id = -1;
							else
							VisitEntity( e2 );
						}
															
					}
				}
			}
		};
		sdCrystal.speciality_table[ 5120 ] = {
			
			AlterTitle: ( e, base_title )=>
			{
				return 'Burning ' + base_title.toLowerCase();
			},
			
			onThink: ( e, GSPEED )=>
			{
				if ( sdWorld.is_server )
				{
					//e.ApplyStatusEffect({ type: sdStatusEffect.TYPE_TEMPERATURE, t: 100 * GSPEED });
					if ( e.is_very_depleted )
					{
						e.speciality = 0;
					}
					else
					e.ApplyStatusEffect({ type: sdStatusEffect.TYPE_TEMPERATURE, target_value:1000, remain_part: 0.8, GSPEED:GSPEED }); // 700-800 won't cause fire spreading // 1000 is not enough to burn stuff around on its own, but can burn stuff when couple of such crystals are there
				}
			},
			
			isFireAndAcidDamageResistant: ( e )=>
			{
				return true;
			}
		};
		sdCrystal.speciality_table[ 10240 ] = {
			
			AlterTitle: ( e, base_title )=>
			{
				if ( e.speciality === 1 )
				return 'Indifferent ' + base_title.toLowerCase();
			
				return 'Medusa ' + base_title.toLowerCase();
			},
			
			GetFilterAltering: ( e, ctx_filter )=>
			{
				if ( e.speciality === 1 )
				return ctx_filter + 'brightness(0.5)saturate(0.1)contrast(2)hue-rotate(60deg)';
			
				return ctx_filter + 'brightness(0.8)saturate(0)contrast(1.3)';
			},
			
			AlterTimeScale: ( e, GSPEED_scaled )=>
			{
				if ( e.speciality === 2 )
				{
					if ( e._anything_near )
					for ( let i = 0; i < e._anything_near.length; i++ )
					{
						let e2 = e._anything_near[ i ];
						
						e._private_props.medusa_cooldown = Math.max( 0, ( e._private_props.medusa_cooldown || 0 ) - GSPEED_scaled );

						if ( e._private_props.medusa_cooldown > 0 )
						break;

						if ( e2.is( sdCrystal ) )
						if ( e2.GetTier() !== e.GetTier() || e2.speciality !== e.speciality )
						//if ( e2.GetTier() < e.GetTier() )
						if ( !e2.is_anticrystal )
						{
							e2.SetTier( e.GetTier() );
							
							e2.speciality = e.speciality;
							
							sdCrystal.Zap( e, e2, '#ffaa00' );
							sdSound.PlaySound({ name:'drone_explosion', x:e.x, y:e.y, volume:1, pitch: 0.6 });
							
							e._private_props.medusa_cooldown = 10 + Math.random() * 10;
							e2._private_props.medusa_cooldown = 10 + Math.random() * 10;
						}
					}
					return 0.05;
				}
				
				return 0.01;
			},
			
			onDamage: ( e, dmg, initiator=null, was_alive=true )=>
			{
				if ( e.speciality === 2 )
				e._hea = Math.min( e._hmax, e._hea + dmg * 0.7 );
				else
				e._hea = Math.min( e._hmax, e._hea + dmg * 0.99 );
			}
		};
		sdCrystal.speciality_table[ 20480 ] = {
			
			AlterTitle: ( e, base_title )=>{
				return base_title + ' of emptiness';
			},
			
			GetFilterAltering: ( e, ctx_filter )=>
			{
				return ctx_filter + 'sepia(1)saturate(4)hue-rotate(-40deg)brightness(0.7)contrast(2)';
			},
			
			onDamage: ( e, dmg, initiator=null, was_alive=true )=>
			{
				e._hea = Math.min( e._hmax, e._hea + dmg * 0.5 );
			},
			
			onThink: ( e, GSPEED )=>
			{
				if ( sdWorld.is_server )
				if ( !e.held_by || !e.held_by.is( sdMatterAmplifier ) || !e.held_by.shielded )
				if ( e.matter > 100 )
				{
					e._private_props.zap_timer = ( e._private_props.zap_timer || 0 ) + GSPEED;
					
					if ( e._private_props.zap_timer > 60 )
					{
						e._private_props.zap_timer -= 60 * ( 0.5 + Math.random() * 0.5 );
						
						if ( e._anything_near )
						{
							e.matter -= 100;
					
							//let play_sound = 0;
							
							sdWorld.SendEffect({ 
								x:e.x, 
								y:e.y, 
								radius: e.is_big ? 60 : 30,
								damage_scale: 0, // Just a decoration effect
								type:sdEffect.TYPE_EXPLOSION, 
								owner:e,
								color:'#ffff66',
								no_smoke:true,
								shrapnel:true
							});

							for ( let i = 0; i < e._anything_near.length; i++ )
							{
								let e2 = e._anything_near[ i ];

								if ( e2.IsTargetable( e ) )
								{
									sdLost.ApplyAffection( e2, 100, null, sdLost.FILTER_GOLDEN );
								}
							}
							
							sdSound.PlaySound({ name: 'supercharge_combined2_part2', x:e.x, y:e.y, volume: 0.5, pitch: e.is_big?0.5:1 });
						
							//if ( play_sound )
							//sdSound.PlaySound({ name:'drone_explosion', x:e.x, y:e.y, volume:1, pitch: 0.3 });
					
						}
					}
				}
			}
		};
		sdCrystal.speciality_table[ 40960 ] = {
			
			AlterTitle: ( e, base_title )=>{
				return 'Freezing ' + base_title.toLowerCase();
			},
			
			onThinkFrozen: ( e, GSPEED )=>
			{
				e.onThink( GSPEED );
				
				return true; // Prevent regular frozen logic
			},
			
			onThink: ( e, GSPEED )=>
			{
				if ( sdWorld.is_server )
				{
					e.ApplyStatusEffect({ type: sdStatusEffect.TYPE_TEMPERATURE, target_value:-100, remain_part: 0.8, GSPEED:GSPEED });

					let visited_ents = new Set();
					for ( let i = 0; i < 4; i++ )
					{
						let e2 = e.GetRandomEntityNearby( 64 );
						
						if ( e2 )
						if ( !visited_ents.has( e2 ) )
						{
							visited_ents.add( e2 );
							//let old_t = ( e2.is( sdCharacter ) ) ? sdStatusEffect.GetTemperature( e2 ) : 0;

							e2.ApplyStatusEffect({ type: sdStatusEffect.TYPE_TEMPERATURE, target_value:-100, remain_part: 0.8, GSPEED:GSPEED * 0.125 });

							//if ( Math.random() < 0.5 )
							if ( sdWorld.time > e2._last_damage_upg_complain + 6000 )
							if ( e2.is( sdCharacter ) )
							if ( e2._frozen <= 0 )
							{
								let new_t = Math.floor( sdStatusEffect.GetTemperature( e2 ) );

								if ( new_t < 20 )
								{
									e2._last_damage_upg_complain = sdWorld.time;
									
									let new_t_str = ( new_t > 0 ) ? '+'+new_t : new_t;
									
									if ( new_t > 10 )
									e2.Say( [ 
										new_t_str + ' degrees. It is getting really cold there',
										new_t_str + ' degrees. I hope I wont turn into an ice block',
										new_t_str + ' degrees. I better run away now',
										new_t_str + ' degrees. I\'m very cold',
										new_t_str + ' degrees. I should better go to a warmer place',
									][ ~~( Math.random() * 5 ) ] );	
									else
									e2.Say( [ 
										new_t_str + ' degrees. I\'m an icicle now',
										new_t_str + ' degrees. I\'m soon gone',
										new_t_str + ' degrees. I won\'t be able to move soon',
										new_t_str + ' degrees. This is more than chill. Should I be worried?',
										new_t_str + ' degrees. I could really use some fireplace'
									][ ~~( Math.random() * 5 ) ] );
								}
							}
						}
					}
				}
			}
		};
		sdCrystal.speciality_table[ 81920 ] = {
			
			AlterTitle: ( e, base_title )=>
			{
				if ( e.speciality === 1 )
				return 'Anti-asp hive ' + base_title.toLowerCase();
				
				return 'Bit silence ' + base_title.toLowerCase();
			},
			
			GetFilterAltering: ( e, ctx_filter )=>
			{
				if ( e.speciality === 1 )
				return 'hue-rotate(180deg)brightness(0.4)contrast(3)drop-shadow(0px 0px 2px #000000)drop-shadow(0px 0px 5px #ff0000)drop-shadow(0px 0px 2px #000000)';
			
				return 'saturate(0.3)brightness(0.15)contrast(1)drop-shadow(0px 0px 5px #000000)drop-shadow(0px 0px 2px #000000)';
			},
			
			onDraw: ( e, ctx, attached )=>
			{
				if ( e.speciality === 2 )
				{
					let phase = sdWorld.time + ( e._net_id || 0 ) * 1239;
					let amp = 3;
					let an = Math.sin( phase / 56 );
					let s = Math.sin( phase / 20 ) * amp;
					let xx = Math.sin( an ) * s * 0.2;
					let yy = Math.cos( an ) * s;

					ctx.globalAlpha = 1 - Math.abs( s / amp ) * 0.8;

					ctx.save();
					{
						ctx.translate( -xx, -yy );
						e._DefaultDraw( ctx, attached );
					}
					ctx.restore();

					ctx.globalAlpha = ( 1 - Math.abs( s / amp ) * 0.8 ) * Math.abs( s / amp );

					ctx.save();
					{
						ctx.translate( xx, yy );
						e._DefaultDraw( ctx, attached );
					}
					ctx.restore();
					ctx.globalAlpha = 1;
				}
			},
			
			onDamage: ( e, dmg, initiator=null, was_alive=true )=>
			{
				e._hea = Math.min( e._hmax, e._hea + dmg * 0.85 );
				
				if ( e._hea <= 0 && was_alive )
				{
					sdWorld.SendEffect({ 
						x:e.x, 
						y:e.y, 
						radius:80, 
						damage_scale: 0,
						type:sdEffect.TYPE_EXPLOSION_NON_ADDITIVE, 
						owner:initiator,
						color:'#000000',
						no_smoke:true,
						shrapnel:true
					});
				}
			},
			
			onThink: ( e, GSPEED )=>
			{
				if ( e.speciality === 1 )
				{
					if ( sdWorld.is_server )
					if ( !e.held_by || !e.held_by.is( sdMatterAmplifier ) || !e.held_by.shielded )
					if ( e.matter > 100 )
					{
						e._private_props.dupe_timer = ( e._private_props.dupe_timer || 0 ) + GSPEED;
						if ( e._private_props.dupe_timer_max === undefined )
						e._private_props.dupe_timer_max = 20;

						//if ( e._private_props.spawns_left === undefined )
						//e._private_props.spawns_left = 10;

						if ( e._private_props.dupe_timer > e._private_props.dupe_timer_max )
						{
							e._private_props.dupe_timer = 0;

							//if ( e._private_props.spawns_left > 0 )
							{
								//e._private_props.spawns_left--;

								let spawns = Math.min( 3, e.matter / 100 )

								if ( spawns > 0 )
								{
									e.matter -= spawns * 100;

									sdWeather.SimpleSpawner({

										count: [ spawns, spawns ],
										class: sdAsp,
										params: { tier: sdAsp.TIER_ANTI, filter: 'saturate(0)brightness(0.5)contrast(2)', crystal_worth: 81920, attack_through_walls:true },
										aerial: true,

										near_entity: e,
										group_radius: e._hitbox_x2 + 16,

										allow_near_player: true
									});
								}
							}
						}
					}
				}
				else
				if ( e.speciality === 2 )
				{
					if ( e._anything_near )
					for ( let i = 0; i < e._anything_near.length; i++ )
					{
						let e2 = e._anything_near[ i ];
						
						if ( typeof e2.matter !== 'undefined' )
						e2.matter = 0;
						
						if ( typeof e2._matter !== 'undefined' )
						e2._matter = 0;
						
						//e2.ApplyStatusEffect({ type: sdStatusEffect.TYPE_VOID_SHARD_EFFECT, t: 90 });
						
						/*if ( e2.is( sdCharacter ) )
						{
							e2.time_ef = Math.max( e2.time_ef, 3000 );
						}*/
					}
				}
			}
		};
		
		sdWorld.entity_classes[ this.name ] = this; // Register for object spawn
	}
	
	/*get hitbox_x1() { return this.should_draw === 0 ? -2 : this.type === 2 ? -14 : -4; }
	get hitbox_x2() { return this.should_draw === 0 ? 2 : this.type === 2 ? 14 : 5; }
	get hitbox_y1() { return this.should_draw === 0 ? -2 : this.type === 2 ? -14 : -7; }
	get hitbox_y2() { return this.should_draw === 0 ? 2 : this.type === 2 ? 16 : 5; }*/
	get hitbox_x1() { return this.type === sdCrystal.TYPE_CRYSTAL_BALLOON ? -6 : this.type === sdCrystal.TYPE_CRYSTAL_BIG || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ? -14 : -4; }
	get hitbox_x2() { return this.type === sdCrystal.TYPE_CRYSTAL_BALLOON ? 7 : this.type === sdCrystal.TYPE_CRYSTAL_BIG || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ? 14 : 5; }
	get hitbox_y1() { return this.type === sdCrystal.TYPE_CRYSTAL_BALLOON ? -6 : this.type === sdCrystal.TYPE_CRYSTAL_BIG || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ? -14 : this.type === sdCrystal.TYPE_CRYSTAL_ARTIFICIAL ? -4 : -7; }
	get hitbox_y2() { return this.type === sdCrystal.TYPE_CRYSTAL_BALLOON ? 7 : this.type === sdCrystal.TYPE_CRYSTAL_BIG || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ? 16 : 5; }
	
	get hard_collision() // For world geometry where players can walk
	//{ return this.held_by !== null ? false : true; }
	{ return ( !this.held_by || !this.held_by.CrystalHasHardCollision || this.held_by.CrystalHasHardCollision( this ) ); }
	
	/* Causes client-side falling through unsynced ground, probably bad thing to do and it won't be complex entity after sdSnapPack is added
	get is_static() // Static world objects like walls, creation and destruction events are handled manually. Do this._update_version++ to update these
	{ return true; }*/
	
	IsTargetable( by_entity=null, ignore_safe_areas=false ) // Guns are not targetable when held, same for sdCharacters that are driving something
	{
		if ( this.held_by )
		if ( this.held_by.shielded )
		return false;
	
		return true;
	}
	
	get title()
	{
		//if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
		//return this.is_anticrystal ? T('Balloon-like anti-crystal') : T('Balloon-like crystal');
		
		let t = 'Crystal';
		
		if ( this.type === sdCrystal.TYPE_EXCAVATOR_QUARTZ )
		t = 'Excavator quartz';
		
		if ( this.is_anticrystal )
		t = 'Anti-' + t.toLowerCase();
		
		if ( this.speciality > 0 )
		{
			let tier = this.GetTier() * 40;
			let methods = sdCrystal.speciality_table[ tier ];
			if ( methods && methods.AlterTitle )
			t = methods.AlterTitle( this, t );
		}
	
		if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
		t = 'Balloon-like ' + t.toLowerCase();
		
		//if ( this.type === sdCrystal.TYPE_EXCAVATOR_QUARTZ )
		//return T('Excavator quartz');
		
		if ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG )
		t += ' crab';
	
		if ( this.is_big )
		t = 'Large ' + t.toLowerCase();
	
		if ( !this.is_natural )
		t = 'Artificial ' + t.toLowerCase();
	
		if ( this.is_depleted )
		t = 'Depleted ' + t.toLowerCase();
		else
		if ( this.is_overcharged )
		t = 'Overcharged ' + t.toLowerCase();
		
		return t;//T( t );
	}
	
	/*get should_draw()
	{
		throw new Error('Obsolete, use this.held_by instead');
	}
	set should_draw( v )
	{
		throw new Error('Obsolete, use this.held_by instead');
	}*/
	
	getRequiredEntities( observer_character ) // Some static entities like sdCable do require connected entities to be synced or else pointers will never be resolved due to partial sync
	{
		if ( this.held_by )
		return [ this.held_by ]; 
	
		return [];
	}
	/*													
	IsCarriable( by_entity ) // In hands
	{
		return !this.is_big;
	}*/
	
	get is_natural()
	{ return ( this.type !== sdCrystal.TYPE_CRYSTAL_ARTIFICIAL ); }
	
	get is_big() // is_large // is_cluster
	{ return ( this.type === sdCrystal.TYPE_CRYSTAL_BIG || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ); }
	
	get is_crab()
	{ return ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ); }
	
	get is_anticrystal()
	{
		if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
		return this.matter_max === sdCrystal.anticrystal_value * 0.25;
		
		return ( 
				this.matter_max === sdCrystal.anticrystal_value && 
				this.type !== sdCrystal.TYPE_CRYSTAL_BIG && 
				this.type !== sdCrystal.TYPE_CRYSTAL_CRAB_BIG 
			)
			|| 
			( 
				this.matter_max === sdCrystal.anticrystal_value * 4 && 
				( 
					this.type === sdCrystal.TYPE_CRYSTAL_BIG || 
					this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG 
				)
			);
	}
	
	get is_depleted()
	{ return ( this.matter_regen <= 33 ); }
	
	get is_very_depleted()
	{ return ( this.matter_regen <= 5 ); }
	
	get is_overcharged()
	{ return ( this.matter_regen > 133 ); }
	
	GetAutoConnectedEntityForMatterFlow()
	{
		return this.held_by;
	}
	
	isFireAndAcidDamageResistant()
	{
		if ( this.speciality > 0 )
		{
			let methods = sdCrystal.speciality_table[ this.GetTier() * 40 ];
			if ( methods && methods.isFireAndAcidDamageResistant )
			return methods.isFireAndAcidDamageResistant( this );
		}
		
		return false;
	}
	GetBleedEffect()
	{
		if ( this.speciality > 0 )
		{
			let methods = sdCrystal.speciality_table[ this.GetTier() * 40 ];
			if ( methods && methods.GetBleedEffect )
			return methods.GetBleedEffect( this );
		}
		
		return sdEffect.TYPE_WALL_HIT;
	}
	
	get bounce_intensity()
	{
		if ( this.speciality > 0 )
		{
			let methods = sdCrystal.speciality_table[ this.GetTier() * 40 ];
			if ( methods && methods.BouncinessAltering )
			return methods.BouncinessAltering( this );
		}
		
		return this.type === sdCrystal.TYPE_CRYSTAL_BALLOON ? 0.7 : 0;
	}
	
	get friction_remain()
	{ return this.type === sdCrystal.TYPE_CRYSTAL_BALLOON ? 0.9 : 0.8; }
	
	get speciality_tier()
	{
		return this.GetTier() * 40;
	}
	
	GetTier()
	{
		if ( this.is_big )
		return this.matter_max / 4 / 40;
	
		if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
		return this.matter_max * 4 / 40;
	
		return this.matter_max / 40;
	}
	SetTier( target_tier )
	{
		let e2 = this;
		let ratio = 1 / target_tier * e2.GetTier();
		e2.matter_regen = e2.matter_regen * ratio;

		e2.matter_max /= ratio;
		e2.matter_regen = Math.min( e2.matter_regen, e2.max_matter_regen );
		e2.matter = Math.min( e2.matter, e2.matter_max );
	}
	
	GetSpecialityMethods()
	{
		let tier = this.GetTier() * 40;
		let methods = sdCrystal.speciality_table[ tier ];
		return methods;
	}
	
	constructor( params )
	{
		super( params );
		
		//if ( !sdWorld.is_server )
		//globalThis.EnforceChangeLog( this, 'x', true, 'nan_catch' );
		
		//let is_really_deep = params.tag && params.tag.indexOf( 'really_deep' ) !== -1; // params.tag === 'deep' || params.tag === 'deep_crab';
		
		let is_deep = params.tag && params.tag.indexOf( 'deep' ) !== -1; // params.tag === 'deep' || params.tag === 'deep_crab';
		
		if ( params.tag )
		{
			if ( params.tag.indexOf( 'crab' ) !== -1 && params.type !== sdCrystal.TYPE_CRYSTAL_CRAB_BIG )
			params.type = sdCrystal.TYPE_CRYSTAL_CRAB;
			else
			if ( params.tag.indexOf( 'corrupted' ) !== -1 )
			params.type = sdCrystal.TYPE_CRYSTAL_CORRUPTED;
		}
		
		this.sx = 0;
		this.sy = 0;
		this.type = params.type || 1;
		this.matter_max = ( this.type === sdCrystal.TYPE_CRYSTAL_BIG || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ) ? 160 : 40;
		
		if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
		this.matter_max	= 10;
			
		this._time_amplification = 0;
		
		this._last_amplification_until = 0; // Overcharge mode for matter-based BSUs whenever they are in beeping state
		
		this._being_sawed_time = 0; // By saw. If broken near this time - clusters break into 4 smaller crystals instead

		this.held_by = null; // For amplifiers
		//this.should_draw = 1; // For storage crates, guns have ttl which can make them dissapear // EG: I think I'm missing something, but ttl is for deletion rather than being drawn? Revert to .should_draw if my changes break anything
		
		let bad_luck = 1; // 1.45; // High value crystals are more rare if this value is high
		
		let r = 1 - Math.pow( Math.random(), bad_luck );
		
		
		
		
		//if ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ) Branching is bad since it might cause property synchronization shift and cause crystals to appear with negative matter/regeneration rate
		//{
		this._next_action = sdWorld.time + 2000;
		this.walk_direction = 0;
		this.side = -1;
		this.blink = 0;
		this._blink_until = 0;
		this._last_stand_when = 0;
		this.attack_anim = 0; // For big crystal crabs
		//}
		
		//if ( is_really_deep )
		//r *= 0.25;
		
		
		let depth_tier = Math.max( 0, Math.floor( params.y / 2000 ) );
		//r /= Math.pow( 2, Math.random() * depth_tier );
		r /= Math.pow( 2, Math.pow( Math.random(), 2 ) * depth_tier );
		
		if ( r < 0.00390625 / 8 && is_deep ) // matter consuming crystal
		this.matter_max *= 2048;
		else
		if ( r < 0.00390625 / 4 && is_deep ) // new 2022
		this.matter_max *= 1024;
		else
		if ( r < 0.00390625 / 2 && is_deep ) // new 2022
		this.matter_max *= 512;
		else
		if ( r < 0.00390625 && is_deep ) // new 2022
		this.matter_max *= 256;
		else
		if ( r < 0.0078125 && is_deep ) // glowing, new
		this.matter_max *= 128;
		else
		if ( r < 0.015625 && is_deep ) // Red, new
		this.matter_max *= 64;
		else
		if ( r < 0.03125 && is_deep ) // Pink variation, new (old red)
		this.matter_max *= 32;
		else
		if ( r < 0.0625 )
		this.matter_max *= 16;
		else
		if ( r < 0.125 )
		this.matter_max *= 8;
		else
		if ( r < 0.25 )
		this.matter_max *= 4;
		else
		if ( r < 0.5 )
		this.matter_max *= 2;
		
		this._last_damage = 0; // Sound flood prevention

		this.matter_regen = params.matter_regen || 100; // Matter regeneration rate/percentage, depends on crystal and drains as crystal regenerates matter
		
		if ( typeof params.matter_max !== 'undefined' )
		this.matter_max = params.matter_max;
	
		if ( ( this.matter_max === sdCrystal.anticrystal_value && this.type === 1 ) || ( this.matter_max === sdCrystal.anticrystal_value * 4 && ( this.type === 2 || this.type === 6 ) ) )
		{
			this.matter = 0;
			this._hea = this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ? 800 : 600;
			this._damagable_in = 0;
		}
		else
		{
			this.matter = this.matter_max;
			this._hea = this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ? 300 : this.type === sdCrystal.TYPE_CRYSTAL_BIG ? 240 : this.type === sdCrystal.TYPE_EXCAVATOR_QUARTZ ? 200 : 60;
			this._damagable_in = sdWorld.time + 1000; // Suggested by zimmermannliam, will only work for sdCharacter damage		
		}
		
		if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
		{
			this._hea = 15;
			this._spawn_anim = 0;
		}

		if ( this.type === sdCrystal.TYPE_EXCAVATOR_QUARTZ )
		{
			this._hea = 200;
		}
		
		// Crabs can be healed x2 from original health (from grass)
		if ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG )
		this._hea *= 2; 
		
		this._hmax = this._hea; // For repair logic

		this._current_target = null; // For big crystal crabs
		
		// TODO: speciality should not be random by default... Keep randomness only for ground blocks, perhaps?
		this.speciality = ( ( params.from_ground || params.from_tree ) && Math.random() < 0.05 ) ? 1 : 0; // How much special is this crystal? Each matter_max crystal might have unique abilities
		
		// 10% chance to have speciality of tier 2
		if ( this.speciality === 1 )
		if ( Math.random() < 0.1 )
		this.speciality = 2;
		
		if ( params.speciality !== undefined )
		this.speciality = params.speciality;
	
		this._bounce_anim = 0;
	
		this._private_props = {};
		this.extra = {};
		
		if ( params.from_ground || params.from_tree )
		{
			sdWorld.server_config.ModifyDugOutCrystalProperties( this, params.from_ground, params.from_tree );
		}
	}
	ExtraSerialzableFieldTest( prop )
	{
		return ( prop === '_private_props' || prop === 'extra' );
	}
	
	/*onSnapshotApplied() // To override
	{
		if ( sdWorld.is_server )
		if ( !sdWorld.is_singleplayer )
		{
			//if ( sdWorld.time < 1692486127166 + 1000 * 60 * 60 * 24 * 30 * 1 ) // 1 year for patch to be applied everywhere? Trying to prevent improper crystal attachment to trees
			// Issue still kind of exists on one of servers... 1000 active balloon crystals just lying around
			if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON && ( this.held_by === null || this.held_by.crystal !== this ) )
			{
				Wrong as it happens after crystals are extracted from crates
	
				this.remove();
				this._broken = false;
			}
		}
	}*/

	GetIgnoredEntityClasses() // Null or array, will be used during motion if one is done by CanMoveWithoutOverlap or ApplyVelocityAndCollisions
	{
		return sdCrystal.ignored_classes_array;
	}
	
	static ZapLine( xx, yy, ex, ey, color )
	{
		let di = sdWorld.Dist2D_Vector( xx - ex, yy - ey );

		let p = [];

		p.push({
			x: ex,
			y: ey 
		});

		for ( let i = 0; i < 2; i++ )
		{
			let morph = ( i + 1 ) / 3;

			let an = Math.random() * Math.PI * 2;
			let r = di * 0.333 / 2;

			p.push({
				x: xx * morph + ex * ( 1 - morph ) + Math.sin( an ) * r,
				y: yy * morph + ey * ( 1 - morph ) + Math.cos( an ) * r 
			});
		}

		p.push({
			x: xx,
			y: yy 
		});

		for ( let i = 0; i < p.length-1; i++ )
		sdWorld.SendEffect({ x:p[i].x, y:p[i].y, x2:p[i+1].x, y2:p[i+1].y, type:sdEffect.TYPE_BEAM, color:color });
	}
	static Zap( e, e2, color )
	{
		sdCrystal.ZapLine( e2.x + ( e2.hitbox_x1 + e2.hitbox_x2 ) / 2, e2.y + ( e2.hitbox_y1 + e2.hitbox_y2 ) / 2, e.x, e.y, color );
		/*let xx = e2.x + ( e2.hitbox_x1 + e2.hitbox_x2 ) / 2;
		let yy = e2.y + ( e2.hitbox_y1 + e2.hitbox_y2 ) / 2;

		let di = sdWorld.Dist2D_Vector( xx - e.x, yy - e.y );

		let p = [];

		p.push({
			x: e.x,
			y: e.y 
		});

		for ( let i = 0; i < 2; i++ )
		{
			let morph = ( i + 1 ) / 3;

			let an = Math.random() * Math.PI * 2;
			let r = di * 0.333 / 2;

			p.push({
				x: xx * morph + e.x * ( 1 - morph ) + Math.sin( an ) * r,
				y: yy * morph + e.y * ( 1 - morph ) + Math.cos( an ) * r 
			});
		}

		p.push({
			x: xx,
			y: yy 
		});

		for ( let i = 0; i < p.length-1; i++ )
		sdWorld.SendEffect({ x:p[i].x, y:p[i].y, x2:p[i+1].x, y2:p[i+1].y, type:sdEffect.TYPE_BEAM, color:color });*/
	}
				
	Damage( dmg, initiator=null )
	{
		if ( !sdWorld.is_server )
		return;
	
		if ( initiator )
		if ( initiator._is_being_removed )
		initiator = null;

		if ( initiator )
		if ( initiator.is( sdGuanako ) )
		return;

		//if ( this.held_by !== null )
		//return;
		
		if ( this.held_by )
		if ( typeof this.held_by.DropCrystal !== 'undefined' )
		{
			this.held_by.DropCrystal( this, true );
		}
	
		//if ( initiator !== null )
		if ( initiator === null || initiator.IsPlayerClass() )
		if ( sdWorld.time < this._damagable_in )
		if ( !( initiator && initiator.IsPlayerClass() && initiator.power_ef > 0 ) )
		{
			if ( sdWorld.time > this._last_damage + 75 )
			{
				this._last_damage = sdWorld.time;
				sdSound.PlaySound({ name:'crystal2_short', x:this.x, y:this.y, pitch: 0.75 });
			}
			return;
		}

		if ( initiator )
		if ( !initiator.is( sdCrystal ) )
		if ( !initiator.is( sdCube ) )
		if ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG )
		{
			this._current_target = initiator;
			this._next_action = sdWorld.time;
		}
		
		dmg = Math.abs( dmg );
		
		let was_alive = ( this._hea > 0 );
		
		//if ( isNaN( dmg ) )
		//throw new Error();
		
		//if ( isNaN( this._hea ) )
		//throw new Error();
		
		this._hea -= dmg;
		
		//if ( isNaN( this._hea ) )
		//throw new Error();
				
		if ( this.speciality > 0 )
		{
			let tier = this.GetTier() * 40;
			let methods = sdCrystal.speciality_table[ tier ];
			if ( methods && methods.onDamage )
			methods.onDamage( this, dmg, initiator, was_alive );
		}

		if ( this._hea <= 0 )
		{
			if ( was_alive )
			{
				if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
				{
					sdSound.PlaySound({ name:'pop', x:this.x, y:this.y, volume:0.5, pitch:1.3 });
					sdSound.PlaySound({ name:'glass12', x:this.x, y:this.y, volume:0.1, pitch:0.95 + Math.random() * 0.2 });
				}
				else
				{
					//sdSound.PlaySound({ name:'crystal2', x:this.x, y:this.y, volume:1 });
					sdSound.PlaySound({ name:'glass12', x:this.x, y:this.y, volume:0.5, pitch:0.95 + Math.random() * 0.2 });
				}
				
				if ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG )
				sdSound.PlaySound({ name:'crystal_crab_death', x:this.x, y:this.y, pitch: this.type === 3 ? 1 : 0.5, volume:0.5 });
				
				let replacement_entity = null;
				let drop_reward = true;
				
				if ( this.type === sdCrystal.TYPE_CRYSTAL_BIG || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ) // Big crystals/big crystal crabs
				{
					let xx_tot = 1;
					let yy_tot = 1;
					
					if ( Math.abs( sdWorld.time - this._being_sawed_time ) < 1500 )
					{
						xx_tot = 2;
						yy_tot = 2;
						drop_reward = false;
					}
					
					for ( let xx = 0; xx < xx_tot; xx++ )
					for ( let yy = 0; yy < yy_tot; yy++ )
					{
						let ent = new sdCrystal({ 
							x: this.x, 
							y: this.y + this.hitbox_y2, 
							sx: this.sx, 
							sy: this.sy, 
							type: 1,
							speciality: this.speciality
						});
						
						ent.y -= ent.hitbox_y2;
						
						if ( xx_tot === 2 && yy_tot === 2 )
						{
							if ( xx === 0 )
							ent.x -= 5.5;
							else
							ent.x += 5.5;
						
							if ( yy === 0 )
							ent.y -= 12;
						}
						
						ent.matter_max = this.matter_max / 4;
						ent.matter = this.matter / 4;
						ent.matter_regen = this.matter_regen;

						sdEntity.entities.push( ent );
						sdWorld.UpdateHashPosition( ent, false ); // Optional, but will make it visible as early as possible

						replacement_entity = ent;
					}

					// DropShards( x,y,sx,sy, tot, value_mult, radius=0, shard_class_id=sdGun.CLASS_CRYSTAL_SHARD, normal_ttl_seconds=9, ignore_collisions_with=null, follow=null, speciality=false )
					sdWorld.DropShards( this.x, this.y, this.sx, this.sy, 
						Math.ceil( Math.max( 5, this.matter / this.matter_max * 40 / sdWorld.crystal_shard_value * 0.5 ) ) * ( 4 - xx_tot * yy_tot ),
						this.matter_max / 160,
						8,
						undefined,
						undefined,
						replacement_entity,
						null,
						this.speciality
					);
				}
				else
				sdWorld.DropShards( this.x, this.y, this.sx, this.sy, 
					Math.ceil( Math.max( 5, this.matter / this.matter_max * 40 / sdWorld.crystal_shard_value * 0.5 ) ),
					this.matter_max / 40,
					5,
					undefined,
					undefined,
					replacement_entity,
					null,
					this.speciality
				);
		
				if ( drop_reward )
				{
					let reward_amount = sdEntity.SCORE_REWARD_BROKEN_5K_CRYSTAL * this.matter_max / 5120;

					reward_amount *= Math.min ( this.max_matter_regen / 100, this.matter_regen / 100 );

					if ( this.is_crab ) // Give 40k large crab and 40k large crystal a love.
					{
						reward_amount = Math.max( reward_amount, sdEntity.SCORE_REWARD_BROKEN_CRAB_CRYSTAL );

						if ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG )
						reward_amount = Math.max( reward_amount, sdEntity.SCORE_REWARD_BROKEN_BIG_CRAB_CRYSTAL );
					}

					if ( this.is_anticrystal )
					reward_amount = 0;

					reward_amount = Math.min( 700, ~~( reward_amount ) );

					if ( reward_amount > 0 )
					{
						//this.GiveScoreToLastAttacker( reward_amount );
						sdWorld.GiveScoreToPlayerEntity( reward_amount, replacement_entity || this, true, null );
					}
				}

				this.remove();
			}
		}
		else
		{
			if ( sdWorld.time > this._last_damage + 75 )
			{
				this._last_damage = sdWorld.time;
				sdSound.PlaySound({ name:'crystal2_short', x:this.x, y:this.y, volume:1 });
				
				if ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG )
				{
					sdSound.PlaySound({ name:'crystal_crab_death', x:this.x, y:this.y, pitch: this.type === 3 ? 1.5 : 0.8, volume:0.3 });
					
					this._blink_until = sdWorld.time + 1000;
				}
			}
		}
	}
	
	get mass() { return this.type === sdCrystal.TYPE_CRYSTAL_BALLOON ? 5 : ( this.type === 2 || this.type === 6 ) ? 120 : 30; }
	Impulse( x, y )
	{
		if ( this.held_by )
		return;
	
		this.sx += x / this.mass;
		this.sy += y / this.mass;
		//this.sx += x * 0.1;
		//this.sy += y * 0.1;
	}
	
	Impact( vel ) // fall damage basically. Values below 5 won't be reported due to no-damage area lookup optimization
	{
		let min_vel = 6;
		
		if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
		min_vel = 6.2;
	
		if ( this.speciality > 0 )
		{
			let methods = sdCrystal.speciality_table[ this.GetTier() * 40 ];
			if ( methods && methods.ImpactAltering )
			vel = methods.ImpactAltering( this, vel );
		}
		
		if ( vel > min_vel ) // For new mass-based model
		{
			this.DamageWithEffect( ( vel - 3 ) * 15 );
		}
	}
	
	HeldByLogic( GSPEED )
	{
		// Usually all crystals can regenerate when they are in some amplifiers

		if ( this._hea < this._hmax )
		this._hea = Math.min( this._hmax, this._hea + GSPEED * 0.01 ); // Quite slow

		if ( sdWorld.server_config.base_degradation )
		if ( sdWorld.server_config.base_shielding_units_passive_drain_per_week_blue > 0 )
		if ( this.held_by.is( sdMatterAmplifier ) )
		this.matter_regen = sdWorld.MorphWithTimeScale( this.matter_regen, 0, 1 - sdWorld.server_config.base_shielding_units_passive_drain_per_week_blue, GSPEED * this.held_by.multiplier/8 / ( 30 * 60 * 60 * 24 * 7 ) ); // 20% per week on highest tier
	}
	get max_matter_regen()
	{
		let methods = null;
		if ( this.speciality > 0 )
		methods = sdCrystal.speciality_table[ this.GetTier() * 40 ];
	
		if ( methods )
		if ( methods.GetMaxMatterRegen )
		return methods.GetMaxMatterRegen( this );

		if ( this.is_anticrystal )
		return sdCrystal.max_anti_matter_regen;
	
		return sdCrystal.max_matter_regen;
	}
	onThinkFrozen( GSPEED )
	{
		let methods = null;
		if ( this.speciality > 0 )
		methods = sdCrystal.speciality_table[ this.GetTier() * 40 ];
	
		if ( methods && methods.onThinkFrozen && methods.onThinkFrozen( this, GSPEED ) )
		return;
	
		if ( this.held_by )
		this.HeldByLogic( GSPEED );
		else
		super.onThinkFrozen( GSPEED );
	}
	onThink( GSPEED ) // Class-specific, if needed
	{
		if ( this.is_anticrystal )
		GSPEED *= 0.25;
		
		let methods = null;
		if ( this.speciality > 0 )
		methods = sdCrystal.speciality_table[ this.GetTier() * 40 ];
	
		let GSPEED_scaled = sdGun.HandleTimeAmplification( this, GSPEED );
		
		if ( methods && methods.AlterTimeScale )
		GSPEED_scaled = methods.AlterTimeScale( this, GSPEED_scaled );
	
		if ( sdWorld.time < this._last_amplification_until )
		GSPEED_scaled *= 10000;
		
		if ( this.held_by )
		this.HeldByLogic( GSPEED_scaled );
		else
		{
			
			if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
			{
				let in_water = sdWater.all_swimmers.has( this );
				
				if ( in_water )
				this.sy -= sdWorld.gravity * GSPEED;
				else
				this.sy += sdWorld.gravity * GSPEED * 0.333;
			
				this.sx = sdWorld.MorphWithTimeScale( this.sx, 0, 0.96, GSPEED );
				this.sy = sdWorld.MorphWithTimeScale( this.sy, 0, 0.96, GSPEED );
			}
			else
			{
				this.sy += sdWorld.gravity * GSPEED;
			}
		}
		
		if ( methods && methods.onThink )
		methods.onThink( this, GSPEED );
		
		if ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG )
		{
			if ( sdWorld.is_server )
			{
				if ( this.attack_anim > 0 )
				this.attack_anim -= GSPEED;

				if ( this.matter > 5 )
				{
					if ( sdWorld.time > this._next_action )
					{
						if ( this._current_target ) // If big crystal crab
						{
							if ( this._current_target._is_being_removed || !this._current_target.IsTargetable() || !this._current_target.IsVisible( this ) || sdWorld.Dist2D( this.x, this.y, this._current_target.x, this._current_target.y ) > sdCrystal.max_seek_range + 32 || ( this._current_target.hea || this._current_target._hea || 0 ) <= 0 )
							this._current_target = null;
							else
							if ( !this.CanMoveWithoutOverlap( this.x, this.y, -3 ) )
							{
								this._next_action = sdWorld.time + ( this.matter_max === sdCrystal.anticrystal_value * 4 ? 1600 : 400 );

								this.side = ( this._current_target.x > this.x ) ? 1 : -1;

								this.walk_direction = this.side * 80;

								if ( Math.random() < 0.333 || ( this.sx === 0 && this.y + 50 > this._current_target.y ) )
								{
									this.sy -= 4;
									this.sx += this.side * 0.3;
								}
								this.PhysWakeUp();

								if ( 
					
								this.x + this._hitbox_x2 > this._current_target.x + this._current_target._hitbox_x1 - 5 &&
								this.x + this._hitbox_x1 < this._current_target.x + this._current_target._hitbox_x2 + 5 &&
								this.y + this._hitbox_y2 > this._current_target.y + this._current_target._hitbox_y1 - 5 &&
								this.y + this._hitbox_y1 < this._current_target.y + this._current_target._hitbox_y2 + 5
								
								)
								{
									let xx = this._current_target.x + ( this._current_target._hitbox_x1 + this._current_target._hitbox_x2 ) / 2;
									let yy = this._current_target.y + ( this._current_target._hitbox_y1 + this._current_target._hitbox_y2 ) / 2;
									
									if ( this._current_target.IsTargetable() )
									if ( sdWorld.CheckLineOfSight( this.x, this.y, this._current_target.x, this._current_target.y, null, null, sdCom.com_creature_attack_unignored_classes ) )
									{
										this._next_action += 400;

										this.attack_anim = 8;
										
										this._current_target.DamageWithEffect( 30, this );
					
										this._current_target.PlayDamageEffect( xx, yy );
										//sdWorld.SendEffect({ x:xx, y:yy, type:this._current_target.GetBleedEffect(), filter:this._current_target.GetBleedEffectFilter() });
										
										sdSound.PlaySound({ name:'crystal2_short', x:this.x, y:this.y, volume:1.3, pitch: 0.3 });
									}
									
								}
							}
						}
						else
						{
							this._next_action = sdWorld.time + 1500 + Math.random() * 6000;

							let r = Math.random();

							if ( r < 0.333 )
							this._blink_until = sdWorld.time + 200 + Math.random() * 200;
							else
							if ( r < 0.5 )
							{
								//this.side = Math.random() < 0.5 ? 1 : -1;
								this.sy -= ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ) ? 4 : 3;
								this.walk_direction = this.side * 60;
								this.PhysWakeUp();
							}
							else
							{
								this.walk_direction = -100 + Math.random() * 200;
								this.side = this.walk_direction > 0 ? 1 : -1;
							}
						}
					}
					this.blink = sdWorld.time < this._blink_until;
				}
				else
				this.blink = 1;
			}

			if ( !this.held_by )
			{
				if ( this.walk_direction !== 0 )
				{
					if ( sdWorld.time < this._last_stand_when + 50 )
					{
						this.sx += this.walk_direction * 0.01 * GSPEED;
					}

					this.PhysWakeUp();

					if ( this.walk_direction > 0 )
					this.walk_direction = Math.max( 0, this.walk_direction - GSPEED );
					else
					this.walk_direction = Math.min( 0, this.walk_direction + GSPEED );
				}

				sdWorld.last_hit_entity = null;

				this.ApplyVelocityAndCollisions( GSPEED, 0, this.sy >= 0 );

				if ( sdWorld.last_hit_entity )
				{
					this._last_stand_when = sdWorld.time;
				}
			}
		}
		else
		{
			if ( !this.held_by )
			{
				if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
				this.ApplyVelocityAndCollisions( GSPEED, 8.1, true );
				else
				this.ApplyVelocityAndCollisions( GSPEED, 0, true );
			}
		}
		
		if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
		{
			if ( this._spawn_anim < 1 )
			{
				if ( this.held_by && this.held_by.is( sdGrass ) )
				this._spawn_anim = Math.min( 1, this._spawn_anim + GSPEED * 0.01 );
				else
				this._spawn_anim = 1;
			}
		}
		
		
		//if ( this.held_by === null ) // Don't emit matter if inside a crate

		if ( this.held_by && this.held_by.is( sdGrass ) )
		{
			// Don't emit matter on trees
		}
		else
		{
			if ( this.is_anticrystal )
			{
				if ( this.held_by === null || !this.held_by.shielded )
				{
					this.HungryMatterGlow( 0.01, 100, GSPEED_scaled );
					this.matter = Math.max( 0, this.matter - GSPEED_scaled * 0.01 * this.matter );
				}
			}
			else
			{
				this.MatterGlow( 0.01, 30, GSPEED_scaled ); // This order should make it regen more efficiently when crystals are nearly full
				
				let matter_before_regen = this.matter;

				if ( this.held_by && this.held_by.is( sdMatterAmplifier ) )
				this.matter = Math.min( this.matter_max, this.matter + GSPEED_scaled * 0.001 * this.matter_max / 80 * ( this.matter_regen / 100 ) * ( sdMatterAmplifier.relative_regen_amplification_to_crystals * ( this.held_by.multiplier ) ) );
				else
				this.matter = Math.min( this.matter_max, this.matter + GSPEED_scaled * 0.001 * this.matter_max / 80 * ( this.matter_regen / 100 ) );

				if ( sdWorld.server_config.crystal_matter_regen_decrease )
				this.matter_regen = Math.max( sdCrystal.lowest_matter_regen, this.matter_regen - ( this.matter - matter_before_regen ) / this.matter_max * 100 / sdCrystal.recharges_until_depleated ); // 30 full recharges

				//this.MatterGlow( 0.01, 30, GSPEED_scaled );
			}
		}
		
		// Similar to sdMatterContainers but not really, since it can have consistent slight movement unlike containers
		/*if ( Math.abs( this._last_sync_matter - this.matter ) > this.matter_max * 0.1 || Math.abs( this._last_sync_x - this.x ) >= 1 || Math.abs( this._last_sync_y - this.y ) >= 1 )
		{
			this._last_sync_matter = this.matter;
			this._last_sync_x = this.x;
			this._last_sync_y = this.y;
			this._update_version++;
		}*/
	}
	
	onMovementInRange( from_entity )
	{
		if ( !sdWorld.is_server )
		return;
	
		// Easier crystal combining
		if ( this.held_by )
		{
			if ( this.held_by.is( sdGrass ) ) // On a tree
			if ( from_entity.is( sdCharacter ) || from_entity.is( sdPlayerDrone ) )
			//if ( from_entity.IsPlayerClass() )
			if ( from_entity.hard_collision )
			{
				this.held_by.DropCrystal();
				return;
			}
			
			if ( from_entity )
			if ( from_entity.is( sdCrystal ) )
			if ( from_entity.held_by !== this.held_by )
			{
				this.held_by.onMovementInRange( from_entity );
			}
		}
	}
	DrawHUD( ctx, attached ) // foreground layer
	{
		if ( this.is_anticrystal )
		sdEntity.TooltipUntranslated( ctx, this.title + " ( " + sdWorld.RoundedThousandsSpaces(this.matter) + " / " + sdWorld.RoundedThousandsSpaces(this.matter_max) + " )" );
		else
		{
			// Limit vision to cable managment owner
			/*if ( sdWorld.my_entity.is( sdPlayerDrone ) ||
				( sdWorld.my_entity._inventory[ sdGun.classes[ sdGun.CLASS_CABLE_TOOL ].slot ] && 
				  sdWorld.my_entity._inventory[ sdGun.classes[ sdGun.CLASS_CABLE_TOOL ].slot ].class === sdGun.CLASS_CABLE_TOOL ) )*/
			sdEntity.TooltipUntranslated( ctx, this.title + " ( " + sdWorld.RoundedThousandsSpaces(this.matter) + " / " + sdWorld.RoundedThousandsSpaces(this.matter_max) + " ) (matter regeneration rate: " + ~~(this.matter_regen ) + "%)" );
			/*else
			{
				if ( this.is_depleted )
				sdEntity.TooltipUntranslated( ctx, this.title + " ( " + sdWorld.RoundedThousandsSpaces(this.matter) + " / " + sdWorld.RoundedThousandsSpaces(this.matter_max) + " ) (depleted)" );
				else
				sdEntity.TooltipUntranslated( ctx, this.title + " ( " + sdWorld.RoundedThousandsSpaces(this.matter) + " / " + sdWorld.RoundedThousandsSpaces(this.matter_max) + " )" );
			}*/
		}

		this.BasicCarryTooltip( ctx, 8 );
	}
	HookAttempt() // true for allow. this._current_target is sdBullet that is hook tracer
	{
		if ( !sdWorld.is_server )
		return false;
				
		if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
		{
			setTimeout( ()=>{
				if ( !this._is_being_removed )
				{
					this._damagable_in = 0;
					this.DamageWithEffect( 15 );
				}
			}, 300 );
			//return false;
		}
	
		if ( this.held_by )
		if ( typeof this.held_by.DropCrystal !== 'undefined' )
		{
			this.held_by.DropCrystal( this, true );
		}
		
		return true;
	}
	static DoNothing( filter )
	{
		return filter;
	}
	Draw( ctx, attached )
	{
		if ( this.speciality > 0 )
		{
			let tier = this.GetTier() * 40;
			let methods = sdCrystal.speciality_table[ tier ];
			if ( methods && methods.onDraw )
			{
				methods.onDraw( this, ctx, attached );
				return;
			}
		}
		
		this._DefaultDraw( ctx, attached );
	}
	SetCrystalFilter( ctx, attached, crystal_hue_filter )
	{
		let filter_brightness_effect = sdCrystal.DoNothing;
		
		if ( attached )
		if ( this.held_by )
		if ( this.held_by.ModifyHeldCrystalFilter )
		filter_brightness_effect = ( f )=>{ return this.held_by.ModifyHeldCrystalFilter( f ) };
		
		let f = crystal_hue_filter;

		if ( this.speciality > 0 )
		{
			let tier = this.GetTier() * 40;
			let methods = sdCrystal.speciality_table[ tier ];
			if ( methods && methods.GetFilterAltering )
			{
				f = methods.GetFilterAltering( this, f );
			}
		}

		if ( this.is_very_depleted )
		f += 'saturate(0.15) hue-rotate(-20deg)';
		else
		if ( this.is_depleted )
		f += 'saturate(0.5) hue-rotate(-20deg)';
		else
		if ( this.is_overcharged )
		f += 'saturate(2) brightness(1.5)';

		ctx.filter = filter_brightness_effect( f );
	}
	GetFilterForIllusions()
	{
		let ctx = { filter:'none' };
		let attached = false;

		const setFilter = ( crystal_hue_filter )=>
		{
			this.SetCrystalFilter( ctx, attached, crystal_hue_filter );
		};

		setFilter( 
					sdWorld.GetCrystalHue(
						( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON ) ? this.matter_max * 2 : 
						this.is_big ? this.matter_max / 4 : 
						this.matter_max
					)
		);

		return ctx.filter;
	}
	GetTitleForIllusions()
	{
		let t = this.title;
		
		if ( this.is_anticrystal )
		t += " ( " + sdWorld.RoundedThousandsSpaces( this.matter ) + " / " + sdWorld.RoundedThousandsSpaces( this.matter_max ) + " )";
		else
		t += " ( " + sdWorld.RoundedThousandsSpaces( this.matter ) + " / " + sdWorld.RoundedThousandsSpaces( this.matter_max ) + " ) (matter regeneration rate: " + ~~( this.matter_regen ) + "%)";

		return t;
	}
	_DefaultDraw( ctx, attached )
	{
		//let filter_brightness_effect = sdCrystal.DoNothing;
		
		ctx.apply_shading = false;
		
		/*if ( attached )
		if ( this.held_by )
		if ( this.held_by.ModifyHeldCrystalFilter )
		filter_brightness_effect = ( f )=>{ return this.held_by.ModifyHeldCrystalFilter( f ) };*/
		
		const setFilter = ( crystal_hue_filter )=>
		{
			this.SetCrystalFilter( ctx, attached, crystal_hue_filter );
		};
		
		//for ( let test = 0; test < 3; test++ )
		{
			if ( this.held_by === null || attached )
			{
				if (	this.type === sdCrystal.TYPE_CRYSTAL || 
						this.type === sdCrystal.TYPE_CRYSTAL_CORRUPTED || 
						this.type === sdCrystal.TYPE_CRYSTAL_ARTIFICIAL ||
						this.type === sdCrystal.TYPE_CRYSTAL_BALLOON ||
						this.type === sdCrystal.TYPE_EXCAVATOR_QUARTZ )
				{
					let empty_img = sdCrystal.img_crystal_empty;
					let full_img = sdCrystal.img_crystal;
					let visual_matter_mult = 1;
					let alpha_mult = 1;
					
					if ( this.type === sdCrystal.TYPE_CRYSTAL_ARTIFICIAL )
					{
						empty_img = sdCrystal.img_crystal_artificial_empty;
						full_img = sdCrystal.img_crystal_artificial;
					}
					
					if ( this.type === sdCrystal.TYPE_CRYSTAL_BALLOON )
					{
						empty_img = sdCrystal.img_crystal_balloon_empty;
						full_img = sdCrystal.img_crystal_balloon;
						visual_matter_mult = 4;
						alpha_mult = 0.85;
						
						if ( !sdShop.isDrawing )
						{
							let s = ( 1 - ( Math.cos( this._spawn_anim * Math.PI ) * 0.5 + 0.5 ) ) * 0.9 + 0.1;
							ctx.scale( s, s );
						}
					}
					
					if ( this.type === sdCrystal.TYPE_EXCAVATOR_QUARTZ )
					{
						empty_img = sdCrystal.img_crystal_quartz_empty;
						full_img = sdCrystal.img_crystal_quartz;
					}
					
					let visual_matter_max = this.matter_max * visual_matter_mult;
					let visual_matter = this.matter * visual_matter_mult;
					ctx.drawImageFilterCache( empty_img, - 16, - 16, 32, 32 );
					
					//if ( this.type === sdCrystal.TYPE_EXCAVATOR_QUARTZ ) // I am probably butchering code again - Booraz
					if ( !this.GetSpecialityMethods() )
					{
						visual_matter_max = -1 * visual_matter_mult; // All quartz is white
						visual_matter = ( this.matter / this.matter_max ) * -1 * visual_matter_mult;
					}
				

					setFilter( sdWorld.GetCrystalHue( visual_matter_max ) );

					if ( visual_matter_max === sdCrystal.anticrystal_value )
					ctx.globalAlpha *= ( 0.8 + Math.sin( sdWorld.time / 3000 ) * 0.1 ) * alpha_mult;
					else
					ctx.globalAlpha *= ( visual_matter / visual_matter_max ) * alpha_mult;

					ctx.drawImageFilterCache( full_img, - 16, - 16, 32, 32 );

					ctx.globalAlpha = 1;
					ctx.filter = 'none';

					if ( this.type === sdCrystal.TYPE_CRYSTAL_CORRUPTED )
					{
						ctx.drawImageFilterCache( sdCrystal.img_crystal_corrupted, - 16, - 16, 32, 32 );
					}
				}
				else
				if ( this.type === sdCrystal.TYPE_CRYSTAL_BIG )
				{
					ctx.drawImageFilterCache( sdCrystal.img_crystal_cluster2_empty, - 24, - 24, 48, 48 );

					//ctx.filter = filter_brightness_effect( sdWorld.GetCrystalHue( this.matter_max / 4 ) );
					setFilter( sdWorld.GetCrystalHue( this.matter_max / 4 ) );

					if ( this.matter_max === sdCrystal.anticrystal_value * 4 )
					ctx.globalAlpha *= 0.8 + Math.sin( sdWorld.time / 3000 ) * 0.1;
					else
					ctx.globalAlpha *= this.matter / this.matter_max;

					ctx.drawImageFilterCache( sdCrystal.img_crystal_cluster2, - 24, - 24, 48, 48 );

					ctx.globalAlpha = 1;
					ctx.filter = 'none';
				}
				else
				if ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB || this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG )
				{
					ctx.scale( -this.side, 1 );

					let frame = 0;

					if ( this.walk_direction !== 0 && this.attack_anim <= 0 )
					{
						frame = [ 0, 1, 0, 2 ][ ~~( Math.abs( this.walk_direction / 4 ) % 4 ) ];
					}
					else
					if ( this.blink )
					frame = 3;
					else
					if ( this.attack_anim > 0 )
					frame = 4;

					if ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB )
					ctx.drawImageFilterCache( sdCrystal.img_crystal_crab, frame*32,32,32,32, - 16, - 16, 32,32 );
					else
					ctx.drawImageFilterCache( sdCrystal.img_crystal_crab_big, frame*48,48,48,48, - 24, - 24, 48,48 );

					//ctx.filter = filter_brightness_effect( sdWorld.GetCrystalHue( (this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ) ? this.matter_max / 4: this.matter_max, 0.75, 'aa' ) );
					setFilter( sdWorld.GetCrystalHue( (this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG ) ? this.matter_max / 4: this.matter_max, 0.75, 'aa' ) );

					if ( ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB && this.matter_max === sdCrystal.anticrystal_value ) || ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB_BIG && this.matter_max === sdCrystal.anticrystal_value * 4 ) )
					ctx.globalAlpha *= 0.8 + Math.sin( sdWorld.time / 3000 ) * 0.1;
					else
					ctx.globalAlpha *= this.matter / this.matter_max;

					if ( this.type === sdCrystal.TYPE_CRYSTAL_CRAB )
					ctx.drawImageFilterCache( sdCrystal.img_crystal_crab, frame*32,0,32,32, - 16, - 16, 32,32 );
					else
					ctx.drawImageFilterCache( sdCrystal.img_crystal_crab_big, frame*48,0,48,48, - 24, - 24, 48,48 );

					ctx.globalAlpha = 1;
					ctx.filter = 'none';
				}

			}
			
			//ctx.translate( 0, -16 );
		}
		
		//ctx.apply_shading = true;
	}
	onBeforeRemove() // Class-specific, if needed
	{
		//if ( !sdWorld.is_server )
		//console.warn( 'Crystal ('+this.matter_max+') removed' );
		
		if ( this.held_by )
		if ( typeof this.held_by.DropCrystal !== 'undefined' )
		{
			this.held_by.DropCrystal( this );
		}
		
		/*if ( this._hea <= 0 ) // In else case it was just removed (not best way to check)
		{
			sdWorld.DropShards( this.x, this.y, this.sx, this.sy, 
				Math.ceil( Math.max( 5, this.matter / this.matter_max * 40 / sdWorld.crystal_shard_value * 0.5 ) ),
				this.matter_max / 40
			);
		}*/
	}
	MeasureMatterCost()
	{
		return 0; // Hack
		
		//return this._hmax * sdWorld.damage_to_matter + this.matter;
	}
	
	IsPhysicallyMovable()
	{
		return !this.held_by;
	}
}
//sdCrystal.init_class();

export default sdCrystal;
