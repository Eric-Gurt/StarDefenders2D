import Connection from './connection';
import Channel from '../geckos/channel';
import { ChannelId, ServerOptions } from '@geckos.io/common/lib/types';
export default class WebRTCConnection extends Connection {
    connections: Map<any, any>;
    userData: any;
    peerConnection: RTCPeerConnection;
    channel: Channel;
    additionalCandidates: RTCIceCandidate[];
    private options;
    constructor(id: ChannelId, serverOptions: ServerOptions, connections: Map<any, any>, userData: any);
    doOffer(): Promise<void>;
    get iceConnectionState(): RTCIceConnectionState;
    get localDescription(): {
        type?: undefined;
        sdp?: undefined;
    } | {
        type: RTCSdpType;
        sdp: string;
    };
    get remoteDescription(): {
        type?: undefined;
        sdp?: undefined;
    } | {
        type: RTCSdpType;
        sdp: string;
    };
    get signalingState(): RTCSignalingState;
    applyAnswer(answer: RTCSessionDescription): Promise<void>;
    toJSON: () => {
        iceConnectionState: RTCIceConnectionState;
        localDescription: {
            type?: undefined;
            sdp?: undefined;
        } | {
            type: RTCSdpType;
            sdp: string;
        };
        remoteDescription: {
            type?: undefined;
            sdp?: undefined;
        } | {
            type: RTCSdpType;
            sdp: string;
        };
        signalingState: RTCSignalingState;
        id: ChannelId;
        state: "open" | "closed";
    };
    descriptionToJSON(description: RTCSessionDescription | null, shouldDisableTrickleIce?: boolean): {
        type?: undefined;
        sdp?: undefined;
    } | {
        type: RTCSdpType;
        sdp: string;
    };
    disableTrickleIce(sdp: string): string;
    close(): void;
    waitUntilIceGatheringStateComplete(peerConnection: RTCPeerConnection, options: any): Promise<void>;
}
//# sourceMappingURL=webrtcConnection.d.ts.map