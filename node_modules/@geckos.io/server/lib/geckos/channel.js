"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bridge_1 = __importDefault(require("@geckos.io/common/lib/bridge"));
var eventemitter3_1 = __importDefault(require("eventemitter3"));
var parseMessage_1 = __importDefault(require("@geckos.io/common/lib/parseMessage"));
var constants_1 = require("@geckos.io/common/lib/constants");
var sendMessage_1 = __importDefault(require("@geckos.io/common/lib/sendMessage"));
var reliableMessage_1 = require("@geckos.io/common/lib/reliableMessage");
var ServerChannel = /** @class */ (function () {
    function ServerChannel(webrtcConnection, dataChannelOptions, userData) {
        var _this = this;
        this.webrtcConnection = webrtcConnection;
        this.dataChannelOptions = dataChannelOptions;
        this.userData = userData;
        this.eventEmitter = new eventemitter3_1.default();
        // stores all reliable messages for about 15 seconds
        this.receivedReliableMessages = [];
        this._id = webrtcConnection.id;
        this._roomId = undefined;
        var _a = dataChannelOptions.label, label = _a === void 0 ? 'geckos.io' : _a, _b = dataChannelOptions.ordered, ordered = _b === void 0 ? false : _b, _c = dataChannelOptions.maxRetransmits, maxRetransmits = _c === void 0 ? 0 : _c, _d = dataChannelOptions.maxPacketLifeTime, maxPacketLifeTime = _d === void 0 ? undefined : _d, _e = dataChannelOptions.autoManageBuffering, autoManageBuffering = _e === void 0 ? true : _e;
        this.autoManageBuffering = autoManageBuffering;
        this.dataChannel = webrtcConnection.peerConnection.createDataChannel(label, {
            ordered: ordered,
            maxRetransmits: maxRetransmits,
            maxPacketLifeTime: maxPacketLifeTime
        });
        this.dataChannel.binaryType = 'arraybuffer';
        this.dataChannel.onopen = function () {
            _this.dataChannel.onmessage = function (ev) {
                var _a = parseMessage_1.default(ev), key = _a.key, data = _a.data;
                _this.eventEmitter.emit(key, data);
            };
            // if the dataChannel is open we can safely emit that we have a new open connection
            bridge_1.default.emit(constants_1.EVENTS.CONNECTION, _this);
        };
        this.dataChannel.onclose = function () {
            // this.eventEmitter.removeAllListeners()
        };
    }
    Object.defineProperty(ServerChannel.prototype, "id", {
        /** Get the channel's id. */
        get: function () {
            return this._id;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServerChannel.prototype, "roomId", {
        /** Get the channel's roomId. */
        get: function () {
            return this._roomId;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Listen for the disconnect event.
     * Gets the connectionState 'disconnected', 'failed' or 'closed'. See https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/connectionState
     * @param callback The connectionState.
     */
    ServerChannel.prototype.onDisconnect = function (callback) {
        this.eventEmitter.on(constants_1.EVENTS.DISCONNECT, function (connectionState) {
            var cb = function (connectionState) { return callback(connectionState); };
            cb(connectionState);
        });
    };
    /** Listen for the drop event. */
    ServerChannel.prototype.onDrop = function (callback) {
        this.eventEmitter.on(constants_1.EVENTS.DROP, function (drop) {
            callback(drop);
        });
    };
    /** Close the webRTC connection. */
    ServerChannel.prototype.close = function () {
        this.webrtcConnection.close();
    };
    /** Join a room by its id. */
    ServerChannel.prototype.join = function (roomId) {
        this._roomId = roomId;
    };
    /** Leave the current room. */
    ServerChannel.prototype.leave = function () {
        this._roomId = undefined;
    };
    Object.defineProperty(ServerChannel.prototype, "room", {
        /** Emit a message to all channels in the same room. */
        get: function () {
            var _this = this;
            return {
                /**
                 * Emit a message to the current room.
                 * @param eventName The event name.
                 * @param data The data to send.
                 */
                emit: function (eventName, data, options) {
                    _this.webrtcConnection.connections.forEach(function (connection) {
                        var channel = connection.channel;
                        var roomId = channel.roomId;
                        if (roomId === _this._roomId) {
                            if (options && options.reliable) {
                                reliableMessage_1.makeReliable(options, function (id) {
                                    return channel.emit(eventName, {
                                        MESSAGE: data,
                                        RELIABLE: 1,
                                        ID: id
                                    });
                                });
                            }
                            else {
                                channel.emit(eventName, data);
                            }
                        }
                    });
                }
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ServerChannel.prototype, "broadcast", {
        /** Broadcast a message to all channels in the same room, except the sender's. */
        get: function () {
            var _this = this;
            return {
                /**
                 * Emit a broadcasted message.
                 * @param eventName The event name.
                 * @param data The data to send.
                 */
                emit: function (eventName, data, options) {
                    _this.webrtcConnection.connections.forEach(function (connection) {
                        var channel = connection.channel;
                        var roomId = channel.roomId, id = channel.id;
                        if (roomId === _this._roomId && id !== _this._id) {
                            if (options && options.reliable) {
                                reliableMessage_1.makeReliable(options, function (id) {
                                    return channel.emit(eventName, {
                                        MESSAGE: data,
                                        RELIABLE: 1,
                                        ID: id
                                    });
                                });
                            }
                            else {
                                channel.emit(eventName, data);
                            }
                        }
                    });
                }
            };
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Forward a message to all channels in a specific room.
     * @param roomId The roomId.
     */
    ServerChannel.prototype.forward = function (roomId) {
        var _this = this;
        return {
            /**
             * Emit a forwarded message.
             * @param eventName The event name.
             * @param data The data to send.
             */
            emit: function (eventName, data, options) {
                _this.webrtcConnection.connections.forEach(function (connection) {
                    var channel = connection.channel;
                    var channelRoomId = channel.roomId;
                    if (roomId === channelRoomId) {
                        if (options && options.reliable) {
                            reliableMessage_1.makeReliable(options, function (id) {
                                return channel.eventEmitter.emit(eventName, {
                                    MESSAGE: data,
                                    RELIABLE: 1,
                                    ID: id
                                }, _this._id);
                            });
                        }
                        else {
                            channel.eventEmitter.emit(eventName, data, _this._id);
                        }
                    }
                });
            }
        };
    };
    /**
     * Emit a message to the channel.
     * @param eventName The event name.
     * @param data The data to send.
     * @param options EmitOptions
     */
    ServerChannel.prototype.emit = function (eventName, data, options) {
        var _this = this;
        if (data === void 0) { data = null; }
        if (options && options.reliable) {
            reliableMessage_1.makeReliable(options, function (id) {
                return _this._emit(eventName, {
                    MESSAGE: data,
                    RELIABLE: 1,
                    ID: id
                });
            });
        }
        else {
            this._emit(eventName, data);
        }
    };
    ServerChannel.prototype._emit = function (eventName, data) {
        var _this = this;
        if (data === void 0) { data = null; }
        if (!this._roomId || this._roomId === this._roomId)
            if (!this._id || this._id === this._id) {
                var isReliable = data && typeof data === 'object' && 'RELIABLE' in data;
                var buffering = this.autoManageBuffering && this.dataChannel.bufferedAmount > 0;
                var drop = function (reason, event, data) {
                    _this.eventEmitter.emit(constants_1.EVENTS.DROP, { reason: reason, event: event, data: data });
                };
                // server should never buffer, geckos.io wants to send messages as fast as possible
                if (isReliable || !buffering) {
                    var error = sendMessage_1.default(this.dataChannel, this.maxMessageSize, eventName, data);
                    if (error)
                        drop(constants_1.ERRORS.MAX_MESSAGE_SIZE_EXCEEDED, eventName, data);
                }
                else {
                    drop(constants_1.ERRORS.DROPPED_FROM_BUFFERING, eventName, data);
                }
            }
    };
    Object.defineProperty(ServerChannel.prototype, "raw", {
        /** Send a raw message. */
        get: function () {
            var _this = this;
            return {
                /**
                 * Emit a raw message.
                 * @param rawMessage The raw message. Can be of type 'USVString | ArrayBuffer | ArrayBufferView'
                 */
                emit: function (rawMessage) { return _this.emit(constants_1.EVENTS.RAW_MESSAGE, rawMessage); },
                room: { emit: function (rawMessage) { return _this.room.emit(constants_1.EVENTS.RAW_MESSAGE, rawMessage); } },
                broadcast: { emit: function (rawMessage) { return _this.broadcast.emit(constants_1.EVENTS.RAW_MESSAGE, rawMessage); } }
            };
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Listen for raw messages.
     * @param callback The event callback.
     */
    ServerChannel.prototype.onRaw = function (callback) {
        this.eventEmitter.on(constants_1.EVENTS.RAW_MESSAGE, function (rawMessage) {
            var cb = function (rawMessage) { return callback(rawMessage); };
            cb(rawMessage);
        });
    };
    /**
     * Listen for a message.
     * @param eventName The event name.
     * @param callback The event callback.
     */
    ServerChannel.prototype.on = function (eventName, callback) {
        var _this = this;
        this.eventEmitter.on(eventName, function (data, senderId) {
            if (senderId === void 0) { senderId = undefined; }
            var cb = function (data, senderId) { return callback(data, senderId); };
            // check if message is reliable
            // and reject it if it has already been submitted
            var isReliableMessage = data && data.RELIABLE === 1 && data.ID !== 'undefined';
            var expireTime = 15000; // 15 seconds
            var deleteExpiredReliableMessages = function () {
                var currentTime = new Date().getTime();
                _this.receivedReliableMessages.forEach(function (msg, index, object) {
                    if (msg.expire <= currentTime) {
                        object.splice(index, 1);
                    }
                });
            };
            if (isReliableMessage) {
                deleteExpiredReliableMessages();
                if (_this.receivedReliableMessages.filter(function (obj) { return obj.id === data.ID; }).length === 0) {
                    _this.receivedReliableMessages.push({
                        id: data.ID,
                        timestamp: new Date(),
                        expire: new Date().getTime() + expireTime
                    });
                    cb(data.MESSAGE, senderId);
                }
                else {
                    // reject message
                }
            }
            else {
                cb(data, senderId);
            }
        });
    };
    return ServerChannel;
}());
exports.default = ServerChannel;
//# sourceMappingURL=channel.js.map