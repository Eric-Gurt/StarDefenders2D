"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerChannel = exports.GeckosServer = void 0;
var bridge_1 = __importDefault(require("@geckos.io/common/lib/bridge"));
var http_1 = __importDefault(require("http"));
var channel_1 = __importDefault(require("./channel"));
exports.ServerChannel = channel_1.default;
var constants_1 = require("@geckos.io/common/lib/constants");
var reliableMessage_1 = require("@geckos.io/common/lib/reliableMessage");
var connectionsManager_1 = __importDefault(require("../wrtc/connectionsManager"));
var httpServer_1 = __importDefault(require("../httpServer/httpServer"));
var GeckosServer = /** @class */ (function () {
    function GeckosServer(options) {
        var _a;
        this._cors = { origin: '*', allowAuthorization: false };
        this.connectionsManager = new connectionsManager_1.default(options);
        // auto adjust allow authorization in cors headers
        if (typeof ((_a = options.cors) === null || _a === void 0 ? void 0 : _a.allowAuthorization) === 'undefined' && typeof options.authorization === 'function')
            this._cors.allowAuthorization = true;
        // merge cors options
        this._cors = __assign(__assign({}, this._cors), options.cors);
    }
    Object.defineProperty(GeckosServer.prototype, "connections", {
        // @ts-ignore
        get: function () {
            return this.connectionsManager.connections;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Make the server listen on a specific port.
     * @param port Default port is 9208.
     */
    GeckosServer.prototype.listen = function (port) {
        var _this = this;
        if (port === void 0) { port = 9208; }
        this._port = port;
        // create the server
        this.server = http_1.default.createServer();
        // on server close event
        this.server.once('close', function () {
            _this.connectionsManager.connections.forEach(function (connection) { return connection.close(); });
            bridge_1.default.removeAllListeners();
        });
        // add all routes
        httpServer_1.default(this.server, this.connectionsManager, this._cors);
        // start the server
        this.server.listen(port, function () {
            console.log("Geckos.io signaling server is running on http://localhost:" + port);
        });
    };
    /**
     * Add a existing http server.
     * @param server Your http.Server.
     */
    GeckosServer.prototype.addServer = function (server) {
        var _this = this;
        this.server = server;
        httpServer_1.default(this.server, this.connectionsManager, this._cors);
        // on server close event
        this.server.once('close', function () {
            _this.connectionsManager.connections.forEach(function (connection) { return connection.close(); });
            bridge_1.default.removeAllListeners();
        });
    };
    Object.defineProperty(GeckosServer.prototype, "port", {
        get: function () {
            return this._port;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Emit a message to all channels.
     * @param eventName The event name.
     * @param data The data you want to send.
     * @param options EmitOptions
     */
    GeckosServer.prototype.emit = function (eventName, data, options) {
        this.connections.forEach(function (connection) {
            var channel = connection.channel;
            if (options && options.reliable) {
                reliableMessage_1.makeReliable(options, function (id) {
                    return channel.emit(eventName, {
                        MESSAGE: data,
                        RELIABLE: 1,
                        ID: id
                    });
                });
            }
            else
                channel.emit(eventName, data);
        });
    };
    /**
     * Emit a message to a specific room.
     * @param roomId The roomId.
     */
    GeckosServer.prototype.room = function (roomId) {
        var _this = this;
        if (roomId === void 0) { roomId = undefined; }
        return {
            emit: function (eventName, data) {
                _this.connections.forEach(function (connection) {
                    var channel = connection.channel;
                    var channelRoomId = channel.roomId;
                    if (roomId === channelRoomId) {
                        channel.emit(eventName, data);
                    }
                });
            }
        };
    };
    Object.defineProperty(GeckosServer.prototype, "raw", {
        /** Emit a raw message */
        get: function () {
            var _this = this;
            return {
                emit: function (rawMessage) { return _this.emit(constants_1.EVENTS.RAW_MESSAGE, rawMessage); },
                room: function (roomId) {
                    if (roomId === void 0) { roomId = undefined; }
                    return {
                        emit: function (rawMessage) {
                            _this.room(roomId).emit(constants_1.EVENTS.RAW_MESSAGE, rawMessage);
                        }
                    };
                }
            };
        },
        enumerable: false,
        configurable: true
    });
    /** Listen for a new connection. */
    GeckosServer.prototype.onConnection = function (callback) {
        bridge_1.default.on(constants_1.EVENTS.CONNECTION, function (channel) {
            var cb = function (channel) { return callback(channel); };
            cb(channel);
        });
    };
    return GeckosServer;
}());
exports.GeckosServer = GeckosServer;
/**
 * The geckos.io server library.
 * @param options Pass the geckos.io server options.
 * @param options.iceServers An array of RTCIceServers. See https://developer.mozilla.org/en-US/docs/Web/API/RTCIceServer.
 * @param options.iceTransportPolicy RTCIceTransportPolicy enum defines string constants which can be used to limit the transport policies of the ICE candidates to be considered during the connection process.
 * @param options.label A human-readable name for the channel. This string may not be longer than 65,535 bytes. Default: 'geckos.io'.
 * @param options.ordered Indicates whether or not messages sent on the RTCDataChannel are required to arrive at their destination in the same order in which they were sent (true), or if they're allowed to arrive out-of-order (false). Default: false.
 * @param options.maxPacketLifeTime The maximum number of milliseconds that attempts to transfer a message may take in unreliable mode. While this value is a 16-bit unsigned number, each user agent may clamp it to whatever maximum it deems appropriate. Default: null.
 * @param options.maxRetransmits The maximum number of times the user agent should attempt to retransmit a message which fails the first time in unreliable mode. While this value is a16-bit unsigned number, each user agent may clamp it to whatever maximum it deems appropriate. Default: 0.
 * @param options.cors Set the CORS options.
 * @param options.cors.origin String OR (req: http.IncomingMessage) => string. Default '*'
 * @param options.autoManageBuffering By default, geckos.io manages RTCDataChannel buffering for you. Default 'true'
 * @param options.authorization The async authorization callback
 */
var geckosServer = function (options) {
    if (options === void 0) { options = {}; }
    var iceTransportPolicy = options.iceTransportPolicy;
    if (iceTransportPolicy === 'relay') {
        console.error("WARNING: iceTransportPolicy \"relay\" does not work yet on the server!");
        options.iceTransportPolicy = 'all';
    }
    return new GeckosServer(options);
};
exports.default = geckosServer;
//# sourceMappingURL=server.js.map